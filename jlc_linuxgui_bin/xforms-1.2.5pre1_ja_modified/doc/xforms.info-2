This is xforms.info, produced by makeinfo version 6.7 from xforms.texi.

INFO-DIR-SECTION Development
START-INFO-DIR-ENTRY
* XForms: (xforms). A Graphical user interface toolkit for X
END-INFO-DIR-ENTRY


File: xforms.info,  Node: Adding Button Objects,  Next: Button Types,  Up: Part III Button-like Objects

16.1 Adding Button Objects
==========================

Adding an object To add buttons use one of the following routines:
     FL_OBJECT *fl_add_button(int type, FL_Coord x, FL_Coord y,
                              FL_Coord w, FL_Coord h,
                              const char *label);
     FL_OBJECT *fl_add_lightbutton(int type, FL_Coord x, FL_Coord y,
                                   FL_Coord w, FL_Coord h,
                                   const char *label);
     FL_OBJECT *fl_add_roundbutton(int type, FL_Coord x, FL_Coord y,
                                   FL_Coord w, FL_Coord h,
                                   const char *label);
     FL_OBJECT *fl_add_round3dbutton(int type, FL_Coord x, FL_Coord y,
                                     FL_Coord w, FL_Coord h,
                                     const char *label);
     FL_OBJECT *fl_add_checkbutton(int type, FL_Coord x, FL_Coord y,
                                   FL_Coord w, FL_Coord h,
                                   const char *label);
     FL_OBJECT *fl_add_bitmapbutton(int type, FL_Coord x, FL_Coord y,
                                    FL_Coord w, FL_Coord h,
                                    const char *label);
     FL_OBJECT *fl_add_pixmapbutton(int type, FL_Coord x, FL_Coord y,
                                    FL_Coord w, FL_Coord h,
                                    const char *label);
     FL_OBJECT *fl_add_labelbutton(int type, FL_Coord x, FL_Coord y,
                                   FL_Coord w, FL_Coord h,
                                   const char *label);
     FL_OBJECT *fl_add_scrollbutton(int type, FL_Coord x, FL_Coord y,
                                    FL_Coord w, FL_Coord h,
                                    const char *label);

These finctions create buttons of the following classes:

'FL_BUTTON'
     A standard normal button.

'FL_LIGHTBUTTON'
     A button with a small embedded, colored area that changes color
     when the button is in the on state.

'FL_ROUNDBUTTON'
     A circular button (with a label beside).  The inner area of the
     circle changes color when the button is on.  Often used for radio
     buttons.

'FL_ROUND3DBUTTON'
     Just like the '*note FL_ROUNDBUTTON::' but the circle is dran in a
     3D-fashion.

'FL_CHECKBUTTON'
     Button shaped in the form of a rhombus slightly raised above the
     forms plane when off and slightly embossed (ypically with a
     different color) when on.

'FL_BITMAPBUTTON'
     Button decorated with a bitmap (often read in from an X bitmap file
     with extension 'xbm') in additional to a label.

'FL_PIXMAPBUTTON'
     Button decorated with a pixmap (often read in from an X pixmap file
     with extension 'xpm') in additional to a label.  An additonal
     pixmap can be set for the case that the mouse hoovers over the
     button.

'FL_LABELBUTTON'
     A button that does not appear to be a button, only its label is
     shown, can be used e.g., for hyperlinks.

'FL_SCROLLBARBUTTON'
     A button mostly used at the ends of scrollbars - instead of a label
     it can only contain a triangle pointing up, down, left or right.

The meaning of the parameters is as usual.  The label is by default
placed inside the button for button and lightbutton.  For roundbutton,
round3dbutton, bitmapbutton and pixmapbutton, it is placed to the right
of the circle and to the bottom of the bitmap/pixmap respectively.  For
scrollbutton, the label must be of some pre-determined string that
indicates the direction of the scroll arrow.


File: xforms.info,  Node: Button Types,  Next: Button Interaction,  Prev: Adding Button Objects,  Up: Part III Button-like Objects

16.2 Button Types
=================

The following types of buttons are available:
'FL_NORMAL_BUTTON'
     Returned to '*note fl_do_forms()::' (or having its callback funtion
     invoked) when released.

'FL_PUSH_BUTTON'
     Stays pushed until user pushes it again.

'FL_MENU_BUTTON'
     Returned when pushed, useful e.g., for opening a popup when pushed.

'FL_TOUCH_BUTTON'
     Returned at regulat intervals as long as the user pushes it.

'FL_RADIO_BUTTON'
     Push button that switches off other radio buttons.

'FL_HIDDEN_BUTTON'
     Invisible normal button.

'FL_INOUT_BUTTON'
     Returned both when pushed and when released.

'FL_RETURN_BUTTON'
     Like a normal button but also reacts to the '<Return>' key.

'FL_HIDDEN_RET_BUTTON'
     Invisible return button.

Except for the '*note FL_HIDDEN_BUTTON::' and '*note
FL_HIDDEN_RET_BUTTON::', which are invisible, there's not much visible
indication of the button type but the function is quite different.  For
each of the types the button gets pushed down when the user presses the
mouse on top of it.  What actually happens when the user does so then
depends on the type of the button.  An '*note FL_NORMAL_BUTTON::',
'*note FL_TOUCH_BUTTON::' and '*note FL_INOUT_BUTTON::' gets released
when the user releases the mouse button.  Their difference lies in the
moment at which the interaction routines return them (see below).  A
'*note FL_PUSH_BUTTON::' remains pushed and is only released when the
user pushes it again.  A '*note FL_RADIO_BUTTON::' is a push button with
the following extra property: whenever the user pushes a radio button,
all other pushed radio buttons in the same form (or in the same group)
are released.  In this way the user can make its choice among several
possibilities.  A '*note FL_RETURN_BUTTON::' behaves like a normal
button, but it also reacts when the '<Return>' key on the keyboard is
pressed.  When a form contains such a button (of course there can only
be one) the '<Return>' key can no longer be used to move between input
fields.  For this the '<Tab>' key must be used.

A '*note FL_HIDDEN_BUTTON::' behaves like a normal button but is
invisible.  A '*note FL_HIDDEN_RET_BUTTON::' is like a hidden button but
also reacts to '<Return>' key presses.


File: xforms.info,  Node: Button Interaction,  Next: Other Button Routines,  Prev: Button Types,  Up: Part III Button-like Objects

16.3 Button Interaction
=======================

'*note FL_NORMAL_BUTTON::'s, '*note FL_PUSH_BUTTON::'s, '*note
FL_RADIO_BUTTON::'s, '*note FL_RETURN_BUTTON::'s and '*note
FL_HIDDEN_BUTTON::'s are returned at the moment the user releases the
mouse after having pressed it on the button.  A '*note
FL_MENU_BUTTON::', in contrast, is returned already on a mouse press.  A
'*note FL_INOUT_BUTTON::' is returned both when the user presses it and
when the user releases it.  A '*note FL_TOUCH_BUTTON::' is returned all
the time as long as the user keeps the mouse button pressed while the
mouse is on top of it.  A '*note FL_RETURN_BUTTON::' and a '*note
FL_HIDDEN_RET_BUTTON::' are also returned when the user presses the
'<Return>' key.

As for other "active" objects, you can control under which conditions a
button object gets returned or its callback invoked by using the
function
     int fl_set_object_return(FL_OBJECT *obj, unsigned int when);
where reasonable values for 'when' are
'*note FL_RETURN_NONE::'
     Never return object or invoke callback.

'*note FL_RETURN_END_CHANGED::'
     Return object or invoke callback when mouse button is released and
     at the same moment the state of the button changed.

'*note FL_RETURN_CHANGED::'
     Return object or invoke callback whenever the state of the button
     changes.

'*note FL_RETURN_END::'
     Return object or invoke callback when mouse button is released

'*note FL_RETURN_ALWAYS::'
     Return object or invoke callback on all of the above condtions.

Most buttons will always return '*note FL_RETURN_END::' and '*note
FL_RETURN_CHANGED::' at the same time.  Exceptions are '*note
FL_INOUT_BUTTON::'s and '*note FL_TOUCH_BUTTON::'s.  The former returns
'*note FL_RETURN_CHANGED::' when pushed and both '*note FL_RETURN_END::'
and '*note FL_RETURN_CHANGED::' together when released.  '*note
FL_TOUCH_BUTTON::'s return when pressed, then '*note
FL_RETURN_CHANGED::' at regular time intervals while being pressed and
finally '*note FL_RETURN_END::' when released.

See demo 'butttypes.c' for a feel of the different button types.


File: xforms.info,  Node: Other Button Routines,  Next: Button Attributes,  Prev: Button Interaction,  Up: Part III Button-like Objects

16.4 Other Button Routines
==========================

The application program can also set a button to be pushed or not itself
without a user action.  To this end use the routine
     void fl_set_button(FL_OBJECT *obj, int pushed);
'pushed' indicates whether the button should be set to be pushed (1) or
released (0).  When setting a '*note FL_RADIO_BUTTON::' to be pushed
this automatically releases the currently pushed radio button in the
same form (or group).  Also note that this routine only simulates the
visual appearance but does not affect the program flow in any way, i.e.,
setting a button as being pushed does not invoke its callback or results
in the button becoming returned to the program.  For that follow up the
call of '*note fl_set_button()::' with a call of '*note
fl_trigger_object()::' (or '*note fl_call_object_callback()::').

To figure out whether a button is pushed or not use(1)
     int fl_get_button(FL_OBJECT *obj);

Sometimes you want to give the button a different meaning depending on
which mouse button gets pressed on it.  To find out which mouse button
was used at the last push (or release) use the routine
     int fl_get_button_numb(FL_OBJECT *obj);
It returns one of the constants '*note FL_LEFT_MOUSE::', '*note
FL_MIDDLE_MOUSE::', '*note FL_RIGHT_MOUSE::', '*note
FL_SCROLLUP_MOUSE::' or '*note FL_SCROLLDOWN_MOUSE::' (the latter two
are from the scroll wheel of the mouse).  If the last push was triggered
by a shortcut (see below), the function returns the 'keysym' (ASCII
value if the key used is between 0 and 127) of the key plus '*note
FL_SHORTCUT::'.  For example, if a button has '<Ctrl>-C' as its shortcut
the button number returned upon activation of the shortcut will be
'FL_SHORTCUT + 3' (the ASCII value of '<Ctrl>-C' is 3).

It can also be controlled which mouse buttons a buttons reacts to (per
default a button reacts to all mouse buttons, including the scroll
wheel).  To set which mouse buttons the button reacts to use
     void fl_set_button_mouse_buttons(FL_OBJECT *obj, int mbuttons);
'mbuttons' is the bitwise OR of the numbers 1 for the left mouse button,
2 for the middle, 4 for the right mouse button, 8 for moving the scroll
wheel up "button" and 16 for scrolling down "button".  Per default a
button reacts to all mouse buttons.

To determine which mouse buttons a button is reacting to use
     void fl_get_button_mouse_buttons(FL_OBJECT *obj,
                                      unsigned int *mbuttons);
The value returned via 'mbuttons' is the same value as would be used in
'*note fl_set_button_mouse_buttons()::'.

In a number of situations it is useful to define a keyboard equivalent
for a button.  You might e.g., want to define that '<Ctrl>Q' has the
same meaning as pressing the "Quit" button.  This can be achieved using
the following call:
     void fl_set_button_shortcut(FL_OBJECT *obj, const char *str,
                                 int showUL);
Note that 'str' is a string, not a single character.  This string is a
list of all the characters to become keyboard shortcuts for the button.
E.g., if you use string "^QQq" the button will react on the keys 'q',
'Q' and '<Ctrl>Q'.  (As you see you can use the symbol '^' to indicate
the control key.  Similarly you can use the symbol '#' to indicate the
'<Alt>' key.)  Be careful with your choices.  When the form also
contains input fields you probably don't want to use the normal
printable characters because they can no longer be used for input in the
input fields.  Shortcuts are always evaluated before input fields.
Other special keys, such as '<F1>' etc., can also be used as shortcuts.
*Note Shortcuts::, for details.  Finally, keep in mind that a button of
type 'FL_RETURN_BUTTON' is in fact nothing more than a normal button,
just with the '<Return>' key set as the shortcut.  So don't change the
shortcuts for such a button.

If the third parameter 'showUL' is true and one of the letters in the
object label matches the shortcut the matching letter will be
underlined.  This applies to non-printable characters (such as '#A') as
well in the sense that if the label contains the letter 'a' or 'A' it
will be underlined (i.e., special characters such as '#' and '^' are
ignored when matching).  A false value (0) for 'showUL' turns off
underlining without affecting the shortcut.  Note that although the
entire object label is searched for matching character to underline of
the shortcut string itself only the first (non-special) character is
considered, thus a shortcut string of '"Yy"' for the label '"Yes"' will
result in the letter 'Y' becoming underlined while for '"yY"' it won't.

To set the bitmap to use for a bitmap button the following functions can
be used:
     void fl_set_bitmapbutton_data(FL_OBJECT *obj, int w, int h,
                                   unsigned char *bits);
     void fl_set_bitmapbutton_file(FL_OBJECT *obj, const char *filename);

Similarly, to set the pixmap to use for a pixmap button the following
routines can be used:
     void fl_set_pixmapbutton_data(FL_OBJECT *obj, unsigned char **bits);
     void fl_set_pixmapbutton_file(FL_OBJECT *obj, const char *file);
     void fl_set_pixmapbutton_pixmap(FL_OBJECT *obj, Pixmap id,
                                      Pixmap mask);
To use the first routine, you '#include' the pixmap file into your
source code and use the pixmap definition data (an array of char
pointers) directly.  For the second routine the filename 'file' that
contains the pixmap definition is used to specify the pixmap.  The last
routine assumes that you already have a X Pixmap resource ID for the
pixmap you want to use.  Note that these routines do not free a pixmap
already associated with the button.  To free the pixmaps use the
function
     void fl_free_pixmapbutton_pixmap(FL_OBJECT *obj);
This function frees the pixmap and mask together with all the colors
allocated for them.

To get the pixmap and mask that is currently being displayed, use the
following routine
     Pixmap fl_get_pixmapbutton_pixmap(FL_OBJECT *obj,
                                       Pixmap &pixmap, Pixmap &mask);

Pixmaps are by default displayed centered inside the bounding box.
However, this can be changed using the following routine
     void fl_set_pixmapbutton_align(FL_OBJECT *obj, int align,
                                    int xmargin, int ymargin);
where 'align' is the same as that used for labels.  *Note Label
Attributes and Fonts::, for a list.  'xmargin' and 'ymargin' are extra
margins to leave in addition to the object border width.  Note that
although you can place a pixmap outside of the bounding box, it probably
is not a good idea.

When the mouse enters a pixmap button an outline of the button is shown.
If required, a different pixmap (the focus pixmap) can also be shown.
To set such a focus pixmap the following functions are available:
     void fl_set_pixmapbutton_focus_data(FL_OBJECT *obj,
                                          unsigned char **bits);
     void fl_set_pixmapbutton_focus_file(FL_OBJECT *obj,
                                         const char *file);
     void fl_set_pixmapbutton_focus_pixmap(FL_OBJECT *obj, Pixmap id,
                                           Pixmap mask);
The meanings of the parameters are the same as that in the regular
pixmap routines.

Finally, there's a function that can be used to enable or disable the
focus outline
     void fl_set_pixmapbutton_focus_outline(FL_OBJECT *obj, int yes_no);
See also *note Pixmap Object::, for pixmap color and transparency
handling.

To get rid of a focus pixmap of a pixmap button use the function
     void fl_free_pixmap_focus_pixmap(FL_OBJECT *obj);

   ---------- Footnotes ----------

   (1) '*note fl_mouse_button()::' can also be used.


File: xforms.info,  Node: Button Attributes,  Next: Button Remarks,  Prev: Other Button Routines,  Up: Part III Button-like Objects

16.5 Button Attributes
======================

For normal buttons the first color argument ('col1') to '*note
fl_set_object_color()::' controls the normal color and the second
('col2') the color the button has when pushed.  For lightbuttons 'col1'
is the color of the light when off and 'col2' the color when on.  For
round buttons, 'col1' is the color of the circle and 'col2' the color of
the circle that is placed inside it when pushed.  For round3dbutton,
'col1' is the color of the inside of the circle and 'col2' the color of
the embedded circle.  For bitmapbuttons, 'col1' is the normal box color
(or bitmap background if boxtype is not 'FL_NO_BOX') and 'col2' is used
to indicate the focus color.  The foreground color of the bitmap is
controlled by label color (as set via '*note fl_set_object_lcolor()::'.
For scrollbutton, 'col1' is the overall boundbox color (if boxtype is
not 'FL_NO_BOX'), 'col2' is the arrow color.  The label of a
scrollbutton must be a string with a number between 1 and 9 (except 5),
indicating the arrow direction like on the numerical key pad.  The label
can have an optional prefix '#' to indicate uniform scaling.  For
example, the label '"#9"' tells that the arrow should be pointing
up-right and the arrow has the identical width and height regardless the
overall bounding box size.


File: xforms.info,  Node: Button Remarks,  Prev: Button Attributes,  Up: Part III Button-like Objects

16.6 Remarks
============

See all demo programs, in particular 'pushbutton.c' and 'buttonall.c'
for the use of buttons.


File: xforms.info,  Node: Part III Valuator Objects,  Next: Part III Input Objects,  Prev: Part III Button-like Objects,  Up: Top

17 Valuator Objects
*******************

* Menu:

* Slider Object:      Slider Object
* Scrollbar Object:   Scrollbar Object
* Dial Object:        Dial Object
* Positioner Object:  Positioner Object
* Counter Object:     Counter Object
* Spinner Object:     Spinner Object
* Thumbwheel Object:  Thumbwheel Object


File: xforms.info,  Node: Slider Object,  Next: Scrollbar Object,  Up: Part III Valuator Objects

17.1 Slider Object
==================

Sliders are useful for letting the user indicate a value between some
fixed bounds.  Both horizontal and vertical sliders exist.  They have a
minimum, a maximum and a current value (all floating point values).  The
user can change the current value by shifting the slider with the mouse.
Whenever the value changes, this is reported to the application program.

* Menu:

* Adding Slider Objects:   Adding Slider Objects
* Slider Types:            Slider Types
* Slider Interaction:      Slider Interaction
* Other Slider Routines:   Other Slider Routines
* Slider Attributes:       Slider Attributes
* Remarks:                 Slider Remarks


File: xforms.info,  Node: Adding Slider Objects,  Next: Slider Types,  Up: Slider Object

17.1.1 Adding Slider Objects
----------------------------

Adding an object To add a slider to a form use
     FL_OBJECT *fl_add_slider(int type, FL_Coord x, FL_Coord y,
                              FL_Coord w, FL_Coord h, const char *label);
or
     FL_OBJECT *fl_add_valslider(int type, FL_Coord x, FL_Coord y,
                                 FL_Coord w, FL_Coord h, const char *label);
The meaning of the parameters is as usual.  The label is by default
placed below the slider.  The difference between a normal slider and a
valslider is that for the second type its value is displayed above or to
the left of the slider.


File: xforms.info,  Node: Slider Types,  Next: Slider Interaction,  Prev: Adding Slider Objects,  Up: Slider Object

17.1.2 Slider Types
-------------------

The following types of sliders are available:
'FL_VERT_SLIDER'
     A vertical slider.

'FL_HOR_SLIDER'
     A horizontal slider.

'FL_VERT_FILL_SLIDER'
     A vertical slider, filled from the bottom.

'FL_HOR_FILL_SLIDER'
     A horizontal slider, filled from the left.

'FL_VERT_NICE_SLIDER'
     A nice looking vertical slider.

'FL_HOR_NICE_SLIDER'
     A nice looking horizontal slider.

'FL_VERT_BROWSER_SLIDER'
     A different looking vertical slider.

'FL_HOR_BROWSER_SLIDER'
     A different looking horizontal slider.

'FL_VERT_PROGRESS_BAR'
     A vertical progress bar

'FL_HOR_PROGRESS_BAR'
     A horizontal progress bar

Please note that except for '*note FL_VERT_PROGRESS_BAR::' and '*note
FL_HOR_PROGRESS_BAR::' the label will always drawn on the outside of the
slider (even if you attempt to set an inside alignment).

               [image src="xforms_images/slidertypes.png" ]


File: xforms.info,  Node: Slider Interaction,  Next: Other Slider Routines,  Prev: Slider Types,  Up: Slider Object

17.1.3 Slider Interaction
-------------------------

Whenever the user changes the value of the slider using the mouse, the
slider is returned (unless there's callback function associated with the
object) by the interaction routines.  The slider position is changed by
moving the mouse inside the slider area.  For fine control, hold down
the '<Shift>' key while usinf the slider, in that case the slider
doesn't follow the mouse directly but at a lower speed.

Please note: the '*note FL_VERT_PROGRESS_BAR::' and '*note
FL_HOR_PROGRESS_BAR::' aren't actually valuator objects (they don't
react to any user interaction) but are vor visualization only (i.e.,
showing a progress bar that is changed by the program only), they appear
here because they are directly derived from the '*note
FL_VERT_FILL_SLIDER::' and '*note FL_VERT_FILL_SLIDER::' slider.  Thus
the only way to change the value of objects of these types is by calling
'*note fl_set_slider_value()::'!  To obtain the correct "progress bar"
behaviour you should also update the label accordingly.

In some cases you might not want the slider to be returned or its
callback called each time its value changes.  To change the default,
call the following routine:
     void fl_set_object_return(FL_OBJECT *obj, unsigned int when)
where the parameter 'when' can be one of the four values:
'*note FL_RETURN_NONE::'
     Never return or invoke callback.

'*note FL_RETURN_END_CHANGED::'
     Return or invoke callback at end (mouse release) if value is
     changed since last return.

'*note FL_RETURN_CHANGED::'
     Return or invoke callback whenever the slider value is changed.
     This is the default.

'*note FL_RETURN_END::'
     Return or invoke callback at end (mouse release) regardless if the
     value is changed or not.

'*note FL_RETURN_ALWAYS::'
     Return or invoke callback when the value changed or at end (mouse
     release).  This is a shorthand for
     'FL_RETURN_CHANGED|FL_RETURN_END'.

See the demo program 'objreturn.c' for an example use of this.


File: xforms.info,  Node: Other Slider Routines,  Next: Slider Attributes,  Prev: Slider Interaction,  Up: Slider Object

17.1.4 Other Slider Routines
----------------------------

To change the value and bounds of a slider use the following routines
     void fl_set_slider_value(FL_OBJECT *obj, double val);
     void fl_set_slider_bounds(FL_OBJECT *obj, double min, double max);
By default, the minimum value for a slider is 0.0, the maximum is 1.0
and the value is 0.5.  For vertical sliders the slider position for the
minimum value is at the left, for horizontal sliders at the top of the
slider.  By setting 'nin' to a larger value than 'max' in a call of
'*note fl_set_slider_bounds()::' this can be reversed.

If in a call of '*note fl_set_slider_bounds()::' the actual value of a
slider isn't within the range of the new bounds, its value gets adjusted
to the nearest limit.  When the requested new slider value in a call of
'*note fl_set_slider_value()::' is outside the range of bounds it gets
adjusted to the nearest boundary value.

To obtain the current value or bounds of a slider use
     double fl_get_slider_value(FL_OBJECT *obj);
     void fl_get_slider_bounds(FL_OBJECT *obj, double *min, double *max);

Per default a slider only reacts to the left mouse button.  But
sometimes it can be useful to modify this.  To set this call
     void fl_set_slider_mouse_buttons(FL_OBJECT *obj,
                                      int mbuttons);
'mbuttons' is the bitwise OR of the numbers 1 for the left mouse button,
2 for the middle and 4 for the right mouse button.

To determine which mouse buttons a slider reacts to use
     void fl_get_slider_mouse_buttons(FL_OBJECT *obj,
                                      unsigned int *mbuttons);
The value returned via 'mbuttons' is the same value as would be used in
'*note fl_set_slider_mouse_buttons()::'.


File: xforms.info,  Node: Slider Attributes,  Next: Slider Remarks,  Prev: Other Slider Routines,  Up: Slider Object

17.1.5 Slider Attributes
------------------------

Never use 'FL_NO_BOX' as the boxtype for a slider.  For
'FL_VERT_NICE_SLIDER's and 'FL_HOR_NICE_SLIDER's it's best to use a
'FL_FLAT_BOX' in the color of the background to get the nicest effect.

The first color argument ('col1') to '*note fl_set_object_color()::'
controls the color of the background of the slider, the second ('col2')
the color of the slider itself.

You can control the size of the slider inside the box using the routine
     void fl_set_slider_size(FL_OBJECT *obj, double size);
'size' should be a floating point value between 0.0 and 1.0.  The
default is 'FL_SLIDER_WIDTH', which is 0.1 for regular sliders and 0.15
for browser sliders.  With a value for 'size' of 1.0, the slider covers
the box completely and can no longer be moved.  This function does
nothing if applied to sliders of type 'NICE_SLIDER' and 'FILL_SLIDER'.

To obtain the current setting of the slider size use
     double fl_get_slider_size(FL_OBJECT *obj);

The routine
     void fl_set_slider_precision(FL_OBJECT *obj, int prec);
sets the precision with which the value of the slider is shown.  This
only applies to sliders showing their value, i.e., valsliders.  The
argument must be between 0 and 'FL_SLIDER_MAX_PREC' (currently set to
10).

By default, the value shown by a valslider is the slider value in
floating point format.  You can override the default by registering a
filter function using the following routine
     void fl_set_slider_filter(FL_OBJECT *obj,
                               const char *(*filter)(FL_OBJECT *,
                                                     double value,
                                                     int prec));
where 'value' and 'prec' are the slider value and precision
respectively.  The filter function 'filter' should return a string that
is to be shown.  The default filter is equivalent to the following
     const char *filter(FL_OBJECT *obj, double value, int prec) {
         static char buf[32];

          sprintf(buf, "%.*f", prec, value);
          return buf;
     }


File: xforms.info,  Node: Slider Remarks,  Prev: Slider Attributes,  Up: Slider Object

17.1.6 Remarks
--------------

See the demo program 'demo05.c' for an example of the use of sliders.
See demo programs 'sldsize.c' and 'sliderall.c' for the effect of
setting slider sizes and the different types of sliders.


File: xforms.info,  Node: Scrollbar Object,  Next: Dial Object,  Prev: Slider Object,  Up: Part III Valuator Objects

17.2 Scrollbar Object
=====================

Scrollbars are similar to sliders (as a matter of fact, scrollbars are
made with sliders and scrollbuttons) and alse let the user indicate a
value between some fixed bounds.  Both horizontal and vertical
scrollbars exist.  They have a minimum, maximum and current value (all
floating point values).  The user can change this value by dragging the
sliding bar with the mouse or by pressing the scroll buttons.  Per
default whenever the value changes, it is reported to the application
program via the callback function.

* Menu:

* Adding Scrollbar Objects:   Adding Scrollbar Objects
* Scrollbar Types:            Scrollbar Types
* Scrollbar Interaction:      Scrollbar Interaction
* Other Scrollbar Routines:   Other Scrollbar Routines
* Scrollbar Attributes:       Scrollbar Attributes
* Remarks:                    Scrollbar Remarks


File: xforms.info,  Node: Adding Scrollbar Objects,  Next: Scrollbar Types,  Up: Scrollbar Object

17.2.1 Adding Scrollbar Objects
-------------------------------

To add a scrollbar to a form use
     FL_OBJECT *fl_add_scrollbar(int type, FL_Coord x, FL_Coord y,
                                 FL_Coord w, FL_Coord h, const char *label);
The meaning of the parameters is as usual.  The label is by default
placed below the scrollbar.

               [image src="xforms_images/scrollbars.png" ]


File: xforms.info,  Node: Scrollbar Types,  Next: Scrollbar Interaction,  Prev: Adding Scrollbar Objects,  Up: Scrollbar Object

17.2.2 Scrollbar Types
----------------------

The following types of scrollbar are available:
'FL_VERT_SCROLLBAR'
     A vertical scrollbar.

'FL_HOR_SCROLLBAR'
     A horizontal scrollbar.

'FL_VERT_THIN_SCROLLBAR'
     A different looking vertical scrollbar.

'FL_HOR_THIN_SCROLLBAR'
     A different looking horizontal scrollbar.

'FL_VERT_NICE_SCROLLBAR'
     A vertical scrollbar using 'FL_NICE_SLIDER'.

'FL_HOR_NICE_SCROLLBAR'
     A horizontal scrollbar using 'FL_NICE_SLIDER'.

'FL_VERT_PLAIN_SCROLLBAR'
     Similar to 'FL_THIN_SCROLLBAR'.

'FL_HOR_PLAIN_SCROLLBAR'
     Similar to 'FL_HOR_THIN_SCROLLBAR'.


File: xforms.info,  Node: Scrollbar Interaction,  Next: Other Scrollbar Routines,  Prev: Scrollbar Types,  Up: Scrollbar Object

17.2.3 Scrollbar Interaction
----------------------------

Whenever the user changes the value of the scrollbar, the scrollbar's
callback is called (if one is associated with the scrollbar).  The
scrollbar position can be changed in several ways.  The most simple one
is to left-click on the knob of the scrollbar and move the know while
the left mouse button is kept pressed down.  Left-clicking beside the
know will move the knob in large steps toward the current position of
the mouse, clicking with the middle or right mouse button in smaller
steps.  Small shifts can also be obtained by clicking on one of the
buttons at the side of the scrollbar or by using the scroll-wheel
somehwere over the scrollbar.

You can control under which conditions the scrollbar gets returned to
your application or its callback invoked.  To change the default, call
     void fl_set_object_return(FL_OBJECT *obj, unsigned int when);
where the parameter 'when' can be one of the following four values:
'*note FL_RETURN_NONE::'
     Never return or invoke callback.

'*note FL_RETURN_END_CHANGED::'
     Return or invoke callback at end (mouse release) if value is
     changed (since last return).

'*note FL_RETURN_CHANGED::'
     Return or invoke callback whenever the scrollbar value is changed.
     This is the default.

'*note FL_RETURN_END::'
     Return or invoke callback at end (mouse release) regardless if the
     value is changed or not.

'*note FL_RETURN_ALWAYS::'
     Return or invoke callback whenever value changed or mouse button
     was released.

The default setting for 'when' for a scrollbar object is '*note
FL_RETURN_CHANGED::' (unless during the build of XForms you set the
configuration flag '--enable-bwc-bs-hack' in which case the default is
'*note FL_RETURN_NONE::' to keep backward compatibility with earlier
releases of the library).

See demo program 'objreturn.c' for an example use of this.


File: xforms.info,  Node: Other Scrollbar Routines,  Next: Scrollbar Attributes,  Prev: Scrollbar Interaction,  Up: Scrollbar Object

17.2.4 Other Scrollbar Routines
-------------------------------

To change the value and bounds of a scrollbar use the following
routines:
     void fl_set_scrollbar_value(FL_OBJECT *obj, double val);
     void fl_set_scrollbar_bounds(FL_OBJECT *obj, double min, double max);
By default, the minimum value for a slider is 0.0, the maximum is 1.0
and the value is 0.5.  For vertical sliders the slider position for the
minimum value is at the left, for horizontal sliders at the top of the
slider.  By setting 'min' to a larger value than 'max' in a call of
'*note fl_set_scrollbar_bounds()::' this can be reversed.

If in a call of '*note fl_set_scrollbar_bounds()::' the actual value of
a scrollbar isn't within the range of the new bounds, its value gets
adjusted to the nearest limit.  When the requested new scrollbar value
in a call of '*note fl_set_scrollbar_value()::' is outside the range of
bounds it gets adjusted to the nearest boundary value.

To obtain the current value and bounds of a scrollbar use
     double fl_get_scrollbar_value(FL_OBJECT *obj);
     void fl_get_scrollbar_bounds(FL_OBJECT *obj, double *min, double *max);

By default, if the mouse is pressed beside the the sliding bar, the bar
starts to jumps in the direction of the mouse position.  You can use the
following routine to change this size of the steps being made :
     void fl_set_scrollbar_increment(FL_OBJECT *obj, double lj, double rj);
where 'lj' indicates how much to increment if the left mouse button is
pressed and 'rj' indicates how much to jump if the middle mouse button
pressed.  For example, for the scrollbar in the browser class, the left
mouse jump is made to be one page and middle mouse jump is made to be
one line.  The increment (decrement) value when the scrollbuttons are
pressed is set to the value of the right jump.  The default values for
'lj' and 'rj' are '0.1' and '0.02'.

To obtain the current increment settings, use the following routine
     void fl_get_scrollbar_increment(FL_OBJECT *obj, double *lj, double *sj);

With the function
     int fl_get_scrollbar_repeat(FL_OBJECT *obj);
     void fl_set_scrollbar_repeat(FL_OBJECT *obj, int millisec);
you can determine and control the time delay (in milliseconds) between
jumps of the knob when the mouse button is kept pressed down outside of
the knobs area.  The default value is 100 ms.  The delay for the very
first jump is twice that long in order to avoid jumping to start too
soon when only a single click was intended but the user is a bit slow in
releasing the mouse button.


File: xforms.info,  Node: Scrollbar Attributes,  Next: Scrollbar Remarks,  Prev: Other Scrollbar Routines,  Up: Scrollbar Object

17.2.5 Scrollbar Attributes
---------------------------

Never use 'FL_NO_BOX' as the boxtype for a scrollbar.  For
'FL_VERT_NICE_SCROLLBAR's and 'FL_HOR_NICE_SCROLLBAR's it's best to use
a 'FL_FLAT_BOX' boxtype in the color of the background to get the nicest
effect.

The first color argument ('col1' to '*note fl_set_object_color()::'
controls the color of the background of the scrollbar, the second
('col2') the color of the sliding bar itself.

You can control the size of the sliding bar inside the box using the
routine
     void fl_set_scrollbar_size(FL_OBJECT *obj, double size);
'size' should be a value between 0.0 and 1.0.  The default is
'FL_SLIDER_WIDTH', which is 0.15 for all scrollbars With 'size' set to
1.0, the scrollbar covers the box completely and can no longer be moved.
This function does nothing if applied to scrollbars of type
'FL_NICE_SCROLLBAR'.

The function
     double fl_get_scrollbar_size(FL_OBJECT *obj);
returns the current setting of the scrollbar size.


File: xforms.info,  Node: Scrollbar Remarks,  Prev: Scrollbar Attributes,  Up: Scrollbar Object

17.2.6 Remarks
--------------

See the demo program 'scrollbar.c' for an example of the use of
scrollbars.


File: xforms.info,  Node: Dial Object,  Next: Positioner Object,  Prev: Scrollbar Object,  Up: Part III Valuator Objects

17.3 Dial Object
================

Dial objects are dials that the user can put in a particular position
using the mouse.  They have a minimum, maximum and current value (all
floating point values).  The user can change this value by turning the
dial with the mouse.  Whenever the value changes, this is reported to
the application program.

* Menu:

* Adding Dial Objects:    Adding Dial Objects
* Dial Types:             Dial Types
* Dial Interaction:       Dial Interaction
* Other Dial Routines:    Other Dial Routines
* Dial Attributes:        Dial Attributes
* Remarks:                Dial Remarks


File: xforms.info,  Node: Adding Dial Objects,  Next: Dial Types,  Up: Dial Object

17.3.1 Adding Dial Objects
--------------------------

To add a dial to a form use
     FL_OBJECT *fl_add_dial(int type, FL_Coord x, FL_Coord y,
                            FL_Coord w, FL_Coord h, const char *label);
The meaning of the parameters is as usual.  The label is by default
placed below the dial.


File: xforms.info,  Node: Dial Types,  Next: Dial Interaction,  Prev: Adding Dial Objects,  Up: Dial Object

17.3.2 Dial Types
-----------------

                  [image src="xforms_images/dials.png" ]

The following types of dials are available:
'FL_NORMAL_DIAL'
     A dial with a knob indicating the position.

'FL_LINE_DIAL'
     A dial with a line indicating the position.

'FL_FILL_DIAL'
     The area between initial and current is filled.


File: xforms.info,  Node: Dial Interaction,  Next: Other Dial Routines,  Prev: Dial Types,  Up: Dial Object

17.3.3 Dial Interaction
-----------------------

By default, the dial value is returned to the application when the user
releases the mouse.  It is possible to change this behavior using the
following routine
     void fl_set_object_return(FL_OBJECT *obj, unsigned int when);
where 'when' can be one of the following
'*note FL_RETURN_NONE::'
     Never report or invoke callback.

'*note FL_RETURN_END_CHANGED::'
     Return or invoke callback at end (mouse release) and only if the
     dial value is changed.  This is the default setting.

'*note FL_RETURN_CHANGED::'
     Return or invoke callback whenever the dial value is changed.

'*note FL_RETURN_END::'
     Return or invoke callback at the end regardless if the dial value
     is changed or not.

'*note FL_RETURN_ALWAYS::'
     Return or invoke callback when value has changed or mouse button
     has been released.


File: xforms.info,  Node: Other Dial Routines,  Next: Dial Attributes,  Prev: Dial Interaction,  Up: Dial Object

17.3.4 Other Dial Routines
--------------------------

To change the value of the dial and its bounds use
     void fl_set_dial_value(FL_OBJECT *obj, double val);
     void fl_set_dial_bounds(FL_OBJECT *obj, double min, double max);
By default, the minimum value is 0.0, the maximum is 1.0 and the value
is 0.5.

To obtain the current values of the dial and its bounds use
     double fl_get_dial_value(FL_OBJECT *obj);
     void fl_get_dial_bounds(FL_OBJECT *obj, double *min, double *max);

Sometimes, it might be desirable to limit the angular range a dial can
take or choose an angle other than 0 to represent the minimum value.
For this purpose, use the following routine
     void fl_set_dial_angles(FL_OBJECT *obj, double thetai, double thetaf)
where 'thetai' maps to the minimum value of the dial and 'thetaf' to its
maximum value.  The angles are relative to the origin of the dial, which
is by default at 6 o'clock and rotates clock-wise.  By default, the
minimum angle is 0 and the maximum angle is 360.

To obtain the start and end angles use
     void fl_get_dial_angles(FL_OBJECT *obj, double *thetai, double *thetaf)

By default, crossing from 359.9 to 0 or from 0 to 359.9 is not allowed.
To allowing crossing over, use the following routine
     void fl_set_dial_crossover(FL_OBJECT *obj, int yes_no);
where a true value for 'yes_no' indicates that cross-over is allowed.

In a number of situations you might want dial values to be rounded to
some values, e.g., to integer values.  To this end use the routine
     void fl_set_dial_step(FL_OBJECT *obj, double step);
After this call dial values will be rounded to multiples of 'step'.  Use
a value of 0.0 for 'step' to switch off rounding.

To get the current setting for the rounding steps use
     double fl_get_dial_step(FL_OBJECT *obj);

By default, clock-wise rotation increases the dial value.  To change,
use the following routine
     void fl_set_dial_direction(FL_OBJECT *obj, int dir);
where 'dir' can be either 'FL_DIAL_CCW' or 'FL_DIAL_CW'.

To obtain the direction use
     int fl_get_dial_direction(FL_OBJECT *obj);


File: xforms.info,  Node: Dial Attributes,  Next: Dial Remarks,  Prev: Other Dial Routines,  Up: Dial Object

17.3.5 Dial Attributes
----------------------

You can use any boxtype you like, but the final dial face always appears
to be circular although certain correlation between the requested
boxtype and actual boxtype exists (for example, 'FL_FRAME_BOX' is
translated into a circular frame box.)

The first color argument ('col1' to '*note fl_set_object_color()::'
controls the color of the background of the dial, the second 'col2') the
color of the knob or the line or the fill color.


File: xforms.info,  Node: Dial Remarks,  Prev: Dial Attributes,  Up: Dial Object

17.3.6 Remarks
--------------

The resolution of a dial is about 0.2 degrees, i.e., there are only
about 2000 steps per 360 degrees and, depending on the size of the dial,
it is typically less.

The dial is always drawn with a circular box.  If you specify a
'FL_UP_BOX', a 'FL_OVAL3D_UPBOX' will be used.

See the demo programs 'ldial.c', 'ndial.c' and 'fdial.c' for examples of
the use of dials.


File: xforms.info,  Node: Positioner Object,  Next: Counter Object,  Prev: Dial Object,  Up: Part III Valuator Objects

17.4 Positioner Object
======================

A positioner is an object in which the user can indicate a position with
an x- and a y-coordinate.  It displays a box with a cross-hair cursor in
it (except an invisble positioner, of course).  Clicking the mouse
inside the box changes the position of the cross-hair cursor and, hence,
the x- and y-values.

* Menu:

* Adding Positioner Objects:   Adding Positioner Objects
* Positioner Types:            Positioner Types
* Positioner Interaction:      Positioner Interaction
* Other Positioner Routines:   Other Positioner Routines
* Positioner Attributes:       Positioner Attributes
* Remarks:                     Positioners Remarks


File: xforms.info,  Node: Adding Positioner Objects,  Next: Positioner Types,  Up: Positioner Object

17.4.1 Adding Positioner Objects
--------------------------------

A positioner can be added to a form using the call
     FL_OBJECT *fl_add_positioner(int type, FL_Coord x, FL_Coord y,
                                  FL_Coord w, FL_Coord h, const char *label);
The meaning of the parameters is as usual.  The label is placed below
the box by default.


File: xforms.info,  Node: Positioner Types,  Next: Positioner Interaction,  Prev: Adding Positioner Objects,  Up: Positioner Object

17.4.2 Positioner Types
-----------------------

The following types of positioner exist:
'FL_NORMAL_POSITIONER'
     Cross-hair inside a box.

'FL_OVERLAY_POSITIONER'
     Cross-hair inside a transparent box.

'FL_INVISIBLE_POSITIONER'
     Completely invisible positioner, to be used just for the side
     effect of obtaining a position (typically an object is below below
     it that otherwise would receive user events).

Note that for exatly positioning a '*note FL_OVERLAY_POSITIONER::' or
'*note FL_INVISIBLE_POSITIONER::' over another object you have to take
account of the (absolute value of the) border widths of both the
underlying obkject and the positioner.


File: xforms.info,  Node: Positioner Interaction,  Next: Other Positioner Routines,  Prev: Positioner Types,  Up: Positioner Object

17.4.3 Positioner Interaction
-----------------------------

The user changes the setting of the positioner using the mouse inside
the box.  Per default whenever the values changes, the object is
returned by the interaction routines or its callback invoked (if one
exists.

To change the default use the function
     void fl_set_object_return(FL_OBJECT *obj, unsigned int when);
where 'when' can be one of the following
'*note FL_RETURN_NONE::'
     Never report or invoke callback.

'*note FL_RETURN_END_CHANGED::'
     Return or invoke callback at end (mouse release) and only when the
     positioner ended in a different position than the one it started
     from.

'*note FL_RETURN_CHANGED::'
     Return or invoke callback whenever the positioners value is
     changed, default setting.

'*note FL_RETURN_END::'
     Return or invoke callback at the end only but regardless if the
     positioners value changed or not.

'*note FL_RETURN_ALWAYS::'
     Return or invoke callback when value has changed or mouse button
     has been released.

Per default a positioner only reacts to the left mouse button.  But
sometimes it can be useful to modify which mouse buttons it will reacts
to.  To set this use
     void fl_set_positioner_mouse_buttons(FL_OBJECT *obj,
                                          int mbuttons);
'mbuttons' is the bitwise OR of the numbers 1 for the left mouse button,
2 for the middle, 4 for the right mouse button, 8 for moving the scroll
wheel up "button" and 16 for scrolling down "button".

To determine which mouse buttons a positioner reacts to use
     void fl_get_positioner_mouse_buttons(FL_OBJECT *obj,
                                          unsigned int *mbuttons);
The value returned via 'mbuttons' is the same value as would be used in
'*note fl_set_positioner_mouse_buttons()::'.

Sometimes you may want to assign different meanings to the mouse buttons
used to interact with the positioner.  To find out which one has been
used there's the function
     int fl_get_positioner_numb(FL_OBJECT *obj);
It returns one of the constants '*note FL_LEFT_MOUSE::', '*note
FL_MIDDLE_MOUSE::', '*note FL_RIGHT_MOUSE::', '*note
FL_SCROLLUP_MOUSE::' or '*note FL_SCROLLDOWN_MOUSE::' (the latter two
are from the scroll wheel of the mouse).


File: xforms.info,  Node: Other Positioner Routines,  Next: Positioner Attributes,  Prev: Positioner Interaction,  Up: Positioner Object

17.4.4 Other Positioner Routines
--------------------------------

Usually, a positioner of type '*note FL_OVERLAY_POSITIONER::' is used on
top if another object, e.g., a pixmap object.  If the object below the
positioner is changed, e.g., by setting a new pixmap for the pixmap
object, tis may lead to visual artefacts since the postioner isn't aware
of the changes of the underlying object.  To avoid this call the
function
     void fl_reset_positioner(FL_OBJECT *obj);
before each change to an object below it.

Per defauly the range that the 'x' and 'y' values of a positioner can
assume are controlled via minimum and maximum values for both
directions.  These boundary values can be set by using the functions the
routines:
     void fl_set_positioner_xbounds(FL_OBJECT *obj, double min, double max);
     int fl_set_positioner_ybounds(FL_OBJECT *obj, double min, double max);
When a new positioner object is created the minimum values are 0.0 and
the maximum values are 1.0.  For boundaries in x-direction 'min' and
'max' should be taken to mean the left- and right-most position,
respectively, and for the y-boundaries 'min' and 'max' should be taken
to mean the value at the bottom and value at the top of the positioner,
respectively.

Note that the posituoners value may be changed automatically when
setting new boundaries to make them satisfy the new conditions.

For more complicated situations, i.e., when only a subset of the
positioners value range may be used, a validation function can be
installed (see the 'positioner_overlay' demo program for an example):
     typedef int (*FL_POSITIONER_VALIDATOR (FL_OBJECT * obj,
     									   double x, double y,
     									   double *x_repl, double *y_repl);

     FL_POSITIONER_VALIDATOR
     fl_set_positioner_validator(FL_OBJECT               * obj,
     							FL_POSITIONER_VALIDATOR   validator);
If a non-'NULL' pointer is passed to the function each time a new
position is set the validation function is invoked.  It can return
either 'FL_POSITIONER_INVALID' to indicate that the new valuea aren't
acceptable, in which case the position remains unchanged.  It may also
return 'FL_POSITIONER_VALID' if the values are acceptable.  Finally, the
function may also return modified values via the 'x_repl' and 'y_repl'
pointers and return 'FL_POSITIONER_REPLACED'.  In this case the values
returned are used.  It's the responsibility of the validation function
to make sure that the 'x' and 'y' values satisfy the boundary
restrictions etc.  If it doesn't the results are unpredictable.

To switch off validation pass the function a 'NULL' pointer.  The
function returns a pointer to the previously active validation function
(or 'NULL' if non had been set).  Note that if a new validation function
is set it is immediately called to check that the current position is
still compatible with the new requirements.  If the validation function
returns '*note FL_POSITIONER_INVALID::' in this case the position can't
be corrected to fit the new conditions.  Thus if you write your
validation function in a way that it may return this value it is
advisable to set compilant values for the positions before installing
the validation function.

To programatically change the 'x' and 'y' position use
     int fl_set_positioner_values(FL_OBJECT *obj, double xval, double yval);
     int fl_set_positioner_xvalue(FL_OBJECT *obj, double val);
     int fl_set_positioner_yvalue(FL_OBJECT *obj, double val);
These functions return either '*note FL_POSITIONER_VALID::' if the new
position was acceptable or '*note FL_POSITIONER_REPLACED::' if the value
passed to the function had to be modified due to constraints imposed by
the boundaries the step sizes or a validation routine.  If a validation
routine is set the functions also may return '*note
FL_POSITIONER_INVALID::' if that routine returned this value.

To obtain the current values of the positioner and the bounds use
     double fl_get_positioner_xvalue(FL_OBJECT *obj);
     double fl_get_positioner_yvalue(FL_OBJECT *obj);
     void fl_get_positioner_xbounds(FL_OBJECT *obj, double *min, double *max);
     void fl_get_positioner_ybounds(FL_OBJECT *obj, double *min, double *max);

In a number of situations you might like positioner values to be rounded
to some values, e.g., to integer values.  To this end use the routines
     void fl_set_positioner_xstep(FL_OBJECT *obj, double step);
     void fl_set_positioner_ystep(FL_OBJECT *obj, double step);
After these calls positioner values will be rounded to multiples of
'step'.  Use a value of 0 for 'step' to switch off rounding.

The functions
     void fl_get_positioner_xstep(FL_OBJECT *obj);
     void fl_get_positioner_ystep(FL_OBJECT *obj);
return the current settings for the 'x' and 'y' step size.

Sometimes, it makes more sense for a positioner to have an icon/pixmap
as the background that represents a minified version of the area where
the positioner's values apply.  Type 'FL_OVERLAY_POSITIONER' is
specifically designed for this by drawing the moving cross-hair in XOR
mode as not to erase the background.  A typical creation procedure might
look something like the following
     obj = fl_add_pixmap(FL_NORMAL_PIXMAP, x, y, w, h, label);
     fl_set_pixmap_file(obj, iconfile);
     pos = fl_add_positioner(FL_OVERLAY_POSITIONER, x, y, w, h, label);
Of course, you can overlay this type of positioner on objects other than
a pixmap.  See the demo program 'positionerXOR.c' for an example.


File: xforms.info,  Node: Positioner Attributes,  Next: Positioners Remarks,  Prev: Other Positioner Routines,  Up: Positioner Object

17.4.5 Positioner Attributes
----------------------------

Never use 'FL_NO_BOX' as the boxtype for a positioner of type.
'FL_NORMAL_POSITIONER' (but the other two types will have a box type of
'FL_NO_BOX' per default).

The first color argument ('col1') to '*note fl_set_object_color()::'
controls the color of the box, the second ('col2') the color of the
cross-hair.


File: xforms.info,  Node: Positioners Remarks,  Prev: Positioner Attributes,  Up: Positioner Object

17.4.6 Remarks
--------------

A demo can be found in 'positioner.c'.


File: xforms.info,  Node: Counter Object,  Next: Spinner Object,  Prev: Positioner Object,  Up: Part III Valuator Objects

17.5 Counter Object
===================

A counter provides a different mechanism for the user to select a value.
In consists of a box displaying a value with one or two buttons on each
side.  The user can press these buttons to change the value (and while
the mouse button is kept pressed down the value will continue to change,
slow at first and faster after some time).  If the counter has four
buttons, the left- and right-most button make the value change in large
steps, the other buttons make it change in small steps.

* Menu:

* Adding Counter Objects:   Adding Counter Objects
* Counter Types:            Counter Types
* Counter Interaction:      Counter Interaction
* Other Counter Routines:   Other Counter Routines
* Counter Attributes:       Counter Attributes
* Remarks:                  Counter Remarks


File: xforms.info,  Node: Adding Counter Objects,  Next: Counter Types,  Up: Counter Object

17.5.1 Adding Counter Objects
-----------------------------

To add a counter to a form use
     FL_OBJECT *fl_add_counter(int type, FL_Coord x, FL_Coord y,
                               FL_Coord w, FL_Coord h, const char *label)
The meaning of the parameters is as usual.  The label is by default
placed below the counter.


File: xforms.info,  Node: Counter Types,  Next: Counter Interaction,  Prev: Adding Counter Objects,  Up: Counter Object

17.5.2 Counter Types
--------------------

                [image src="xforms_images/counters.png" ]

The following types of counters are available:
'FL_NORMAL_COUNTER'
     A counter with two buttons on each side.

'FL_SIMPLE_COUNTER'
     A counter with one button on each side.


File: xforms.info,  Node: Counter Interaction,  Next: Other Counter Routines,  Prev: Counter Types,  Up: Counter Object

17.5.3 Counter Interaction
--------------------------

The user changes the value of the counter by keeping his mouse pressed
on one of the buttons.  Per default whenever the mouse is released and
the counter value is changed the counter is returned to the application
program or its callback is invoked.

In some applications you might want the counter to be returned to the
application program (or the callback invoked) e.g., whenever the value
changes and not only when the mouse is released.  To this end use
     void fl_set_object_return(FL_OBJECT *obj, unsigned int when);
where 'when' can be either
'*note FL_RETURN_NONE::'
     Never report or invoke callback.

'*note FL_RETURN_END_CHANGED::'
     Return or invoke callback at end (mouse release) and only if the
     counter value is changed.

'*note FL_RETURN_CHANGED::'
     Return or invoke callback whenever the counter value is changed.
     This is the default setting.

'*note FL_RETURN_END::'
     Return or invoke callback at the end regardless if the counter
     value is changed or not.

'*note FL_RETURN_ALWAYS::'
     Return or invoke callback when the counter value has changed or
     mouse button has been released.


File: xforms.info,  Node: Other Counter Routines,  Next: Counter Attributes,  Prev: Counter Interaction,  Up: Counter Object

17.5.4 Other Counter Routines
-----------------------------

To change the value of the counter, it's bounds and stp size use the
routines
     void fl_set_counter_value(FL_OBJECT *obj, double val);
     void fl_set_counter_bounds(FL_OBJECT *obj, double min, double max);
     void fl_set_counter_step(FL_OBJECT *obj, double small, double large);
The first routine sets the value (default is 0) of the counter, the
second routine sets the minimum and maximum values that the counter will
take (default are -1000000 and 1000000, respectively) and the third
routine sets the sizes of the small and large steps (defaults to 0.1 and
1).  (For simple counters only the small step is used.)

For conflicting settings, bounds take precedence over value, i.e., if
setting a value that is outside of the current bounds, it is clamped.
Also changing the bounds in a way that the current counter value isn't
within the new bounds range anymore will result in its value being
adjusted to the nearest of the new limits.

To obtain the current value of the counter use
     double fl_get_counter_value(FL_OBJECT *obj);

To obtain the current bounds and steps, use the following functions
     void fl_get_counter_bounds(FL_OBJECT *obj, double *min, double *max);
     void fl_get_counter_step(FL_OBJECT *obj, double *small, double *large);

To set the precision (number of digits after the dot) with which the
counter value is displayed use the routine
     void fl_set_counter_precision(FL_OBJECT *obj, int prec);

To determine the current value of the precision use
     int fl_get_counter_precision(FL_OBJECT *obj);

By default, the value shown is the counter value in floating point
format.  You can override the default by registering a filter function
using the following routine
     void fl_set_counter_filter(FL_OBJECT *obj,
                                const char *(*filter)(FL_OBJECT *,
                                                      double value,
                                                      int prec));
where 'value' and 'prec' are the counter value and precision
respectively.  The filter function 'filter' should return a string that
is to be shown.  Note that the default filter is equivalent to the
following
     const char *filter(FL_OBJECT *obj, double value, int prec) {
         static char buf[32];

          sprintf(buf, "%.*f",prec,value);
          return buf;
     }

By default the counter value changes first slowly and the rate of change
then accelerates until a final speed is reached.  The default delay
between value changes is 600 ms at the start and the final delay is
50 ms.  You can change the initial delay by a call of the function
     void fl_set_counter_repeat(FL_OBJECT *obj, int millisec);
and the final delay by using
     void fl_set_counter_min_repeat(FL_OBJECT *obj, int millisec);
where in both cases the argument 'millisec' is the delay in
milli-seconds.  The current settings for the initial and final delay can
be obtained by calling the functions
     int fl_get_counter_repeat(FL_OBJECT *obj);
     int fl_get_counter_min_repeat(FL_OBJECT *obj);

Until version 1.0.91 of the library the delay between changes of a
counter was constant (with a default value of 100 ms).  To obtain this
traditional behaviour simple set the initial and final delay to the same
value.

As a third alternative you can also request that only the first change
of the counter has a different delay from all the following ones.  To
achieve this call
     void fl_set_counter_speedjump(FL_OBJECT *obj, int yes_no);
with a true value for 'yes_no'.  The delay for the first change of the
counter value will then be the one set by '*note
fl_set_counter_repeat()::' and the following delays last as long as set
by '*note fl_set_counter_min_repeat()::'.

To determine the setting for "speedjumping" call
     int fl_get_counter_speedjump(FL_OBJECT *obj);


File: xforms.info,  Node: Counter Attributes,  Next: Counter Remarks,  Prev: Other Counter Routines,  Up: Counter Object

17.5.5 Counter Attributes
-------------------------

Never use 'FL_NO_BOX' as the boxtype for a counter.

The first color argument ('col1') t '*note fl_set_object_color()::'
controls the color of the background of the counter, the second ('col2')
sets the color of the arrow buttons of the counter.


File: xforms.info,  Node: Counter Remarks,  Prev: Counter Attributes,  Up: Counter Object

17.5.6 Remarks
--------------

See demo program 'counter.c' for an example of the use of counters.


File: xforms.info,  Node: Spinner Object,  Next: Thumbwheel Object,  Prev: Counter Object,  Up: Part III Valuator Objects

17.6 Spinner Object
===================

A spinner object is a combination of a (numerical) input field with two
(touch) buttons that allow to increment or decrement the value in the
(editable) input field.  I.e., the user can change the spinners value by
either editing the value of the input field or by using the up/down
buttons shown beside the input field.

There are two types of spinner objects, one for integer and one for
floating point values.  You can set limits on the values that can be
input and you can also set the amount of increment/decrement achieved
when clicking on its buttons.

* Menu:

* Adding Spinner Objects:   Adding Spinner Objects
* Spinner Types:            Spinner Types
* Spinner Interaction:      Spinner Interaction
* Other Spinner Routines:   Other Spinner Routines
* Spinner Attributes:       Spinner Attributes


File: xforms.info,  Node: Adding Spinner Objects,  Next: Spinner Types,  Up: Spinner Object

17.6.1 Adding Spinner Objects
-----------------------------

To add a spinner to a form use
     FL_OBJECT *fl_add_spinner(int type, FL_Coord x, FL_Coord y,
                               FL_Coord w, FL_Coord h, const char *label);
The meaning of the parameters is as usual.  The label is by default
placed on the left of the spinner object.


File: xforms.info,  Node: Spinner Types,  Next: Spinner Interaction,  Prev: Adding Spinner Objects,  Up: Spinner Object

17.6.2 Spinner Types
--------------------

There are two types of spinners, one for input of integer and one for
floating point values:
'FL_INT_SPINNER'
     A spinner that allows input of integer values.

'FL_FLOAT_SPINNER'
     A spinner that allows input of floating point values.

The way a spinner looks like depends on its dimensions.  If it's at
least as wide as it's high the two buttons are drawn above each other to
the right of the input field (and are marked with and up and down
pointing triangle), while when the object is higher than it's wide they
are drawn beside each other and below the input field (and the markers
are then left and right pointing arrows).


File: xforms.info,  Node: Spinner Interaction,  Next: Other Spinner Routines,  Prev: Spinner Types,  Up: Spinner Object

17.6.3 Spinner Interaction
--------------------------

The user can change the value of a spinner in two ways.  She can either
edit the value in the spinner directly (exactly the same as for an
integer or floating point input object (*note Part III Input Objects::)
or by clicking on one of the buttons that will increment or decrement
the value.

Per default the spinner object gets returned to the application (or the
associated callback is called) whenever the value changed and the
interaction seems to have ended.  If you want it returned under
different circumstances use the function
     void fl_set_object_return(FL_OBJECT *obj, unsigned int when);
where the parameter 'when' can be one of the four values
'*note FL_RETURN_NONE::'
     Never return or invoke callback.

'*note FL_RETURN_END_CHANGED::'
     Return or invoke callback at end of interaction (when either the
     input field loses the focus or one of the buttons was released) and
     the spinner's value changed during the interaction.

'*note FL_RETURN_CHANGED::'
     Return or invoke callback whenever the spinner's value changed.
     This is the default.

'*note FL_RETURN_END::'
     Return or invoke callback at end of interaction regardless of the
     spinner's value having changed or not.

'*note FL_RETURN_ALWAYS::'
     Return or invoke callback whenever the value changed or the
     interaction ended.


File: xforms.info,  Node: Other Spinner Routines,  Next: Spinner Attributes,  Prev: Spinner Interaction,  Up: Spinner Object

17.6.4 Other Spinner Routines
-----------------------------

Probably the most often used spinner functions are
     double fl_get_spinner_value(FL_OBJECT *obj );
     double fl_set_spinner_value(FL_OBJECT *obj, double val);
The first one returns the value of a spinner.  The type of the return
value is a double for both integer and floating point spinners, so you
have to convert it for integer spinners appropriately, e.g: using the
'FL_nint()' macro, that converts a double to the nearest integer value.

You can set or retrieve the upper and lower limit the value a spinner
can be set to using the functions
     void fl_set_spinner_bounds(FL_OBJECT *obj, double min, double max);
     void fl_get_spinner_bounds(FL_OBJECT *obj, double *min, double *max);
Since this function is to be used for integer as well as floating point
spinner objects the 'double' type values must be converted as necessary
for '*note FL_INT_SPINNER::'.

The default limits are '-10000' and '10000', but can be set to up to
'INT_MIN' and 'INT_MIN' for '*note FL_INT_SPINNER::'s and '-DBL_MAX' and
'DBL_MAX' for '*note FL_FLOAT_SPINNER::'s.

To set or determine the step size by which a spinner will be incremented
or decremented when one of the buttons is clicked on use
     void fl_set_spinner_step(FL_OBJECT *obj, double step);
     double fl_get_spinner_step(FL_OBJECT *obj);
The default step size is '1' for both '*note FL_INT_SPINNER::' and
'*note FL_FLOAT_SPINNER::' objects.

For '*note FL_FLOAT_SPINNER::' objects you can set (or determine) how
many digits after the decimal point are shown by using
     void fl_set_spinner_precision(FL_OBJECT *obj, int prec);
     int fl_get_spinner_precision(FL_OBJECT *obj);
This is per default set to 6 digits after the decimal point.  The
function for setting the precision has no effect on '*note
FL_INT_SPINNER::' objects and the other one returns 0 for this type of
spinners.


File: xforms.info,  Node: Spinner Attributes,  Prev: Other Spinner Routines,  Up: Spinner Object

17.6.5 Spinner Attributes
-------------------------

Please don't change the boxtype from '*note FL_NO_BOX::'.

The label color and font can be set using the normal '*note
fl_set_object_lcolor()::', '*note fl_set_object_lsize()::' and '*note
fl_set_object_lstyle()::' functions.  The color of the input field of a
spinner object can be set via using '*note fl_set_object_color()::'
where the first color argument ('col1') controls the color of the input
field when it is not selected and the second ('col2') is the color when
selected.

Instead of creating a plethora of functions to influence all the other
aspects of how the spinner is drawn (colors, font types etc.)  the user
is given direct access to the sub-objects of a spinner.  To this end
three functions exist:
     FL_OBJECT *fl_get_spinner_input(FL_OBJECT *obj);
     FL_OBJECT *fl_get_spinner_up_button(FL_OBJECT *obj);
     FL_OBJECT *fl_get_spinner_down_button(FL_OBJECT *obj);
They return the addresses of the objects the spinner object is made up
from, i.e., that of the input field and the buttons for increasing and
decreasing the spinner's value.  These then can be used to set or query
the way the individual component objects are drawn.  The addresses of
these sub-objects shouldn't be used for any other purposes, especially
their callback function may never be changed!


File: xforms.info,  Node: Thumbwheel Object,  Prev: Spinner Object,  Up: Part III Valuator Objects

17.7 Thumbwheel Object
======================

Thumbwheel is another valuator that can be useful for letting the user
indicate a value between some fixed bounds.  Both horizontal and
vertical thumbwheels exist.  They have a minimum, a maximum and a
current value (all floating point values).  The user can change the
current value by rolling the wheel.

* Menu:

* Adding Thumbwheel Objects:   Adding Thumbwheel Objects
* Thumbwheel Types:            Thumbwheel Types
* Thumbwheel Interaction:      Thumbwheel Interaction
* Other Thumbwheel Routines:   Other Thumbwheel Routines
* Thumbwheel Attributes:       Thumbwheel Attributes
* Remarks:                     Thumbwheel Remarks


File: xforms.info,  Node: Adding Thumbwheel Objects,  Next: Thumbwheel Types,  Up: Thumbwheel Object

17.7.1 Adding Thumbwheel Objects
--------------------------------

To add a thumbwheel to a form use
     FL_OBJECT *fl_add_thumbwheel(int type, FL_Coord x, FL_Coord y,
                                  FL_Coord w, FL_Coord h, const char *label);
The meaning of the parameters is as usual.  The label is by default
placed below the thumbwheel.


File: xforms.info,  Node: Thumbwheel Types,  Next: Thumbwheel Interaction,  Prev: Adding Thumbwheel Objects,  Up: Thumbwheel Object

17.7.2 Thumbwheel Types
-----------------------

               [image src="xforms_images/thumbwheels.png" ]

The following types of thumbwheels are available:
'FL_VERT_THUMBWHEEL'
     A vertical thumbwheel.

'FL_HOR_THUMBWHEEL'
     A horizontal thumbwheel.


File: xforms.info,  Node: Thumbwheel Interaction,  Next: Other Thumbwheel Routines,  Prev: Thumbwheel Types,  Up: Thumbwheel Object

17.7.3 Thumbwheel Interaction
-----------------------------

Whenever the user changes the value of the thumbwheel using the mouse or
keyboard, the thumbwheel is returned (or the callback called) by the
interaction routines.  You change the value of a thumbwheel by dragging
the mouse inside the wheel area or, for vertical thumbwheels also by
using the scroll wheel of the mouse.  Each pixel of movement changes the
value of the thumbwheel by 0.005, which you can change using the '*note
fl_set_thumbwheel_step()::' function.

The keyboard can be used to change the value of a thumbwheel.
Specifically, the '<Up>' and '<Down>' cursor keys can be used to
increment or decrement the value of a vertical thumbwheel and the
'<Right>' and '<Left>' cursor keys can be used to increment or decrement
the value of horizontal thumbwheel.  Each pressing of the cursor key
changes the thumbwheel value by the current step value.  The '<Home>'
key can be used to set the thumbwheel to a known value, which is the
average of the minimum and the maximum value of the thumbwheel.

In some applications you might not want the thumbwheel to be returned
all the time.  To change the default, call the following routine:
     void fl_set_object_return(FL_OBJECT *obj, unsigned int when);
where the parameter 'when' can be one of the four values
'*note FL_RETURN_NONE::'
     Never return or invoke callback.

'*note FL_RETURN_END_CHANGED::'
     Return or invoke callback at end (mouse release) if value is
     changed since last return.

'*note FL_RETURN_CHANGED::'
     Return or invoke callback whenever the thumbwheel value is changed.

'*note FL_RETURN_END::'
     Return or invoke callback at end (mouse release) regardless if the
     value is changed or not.

'*note FL_RETURN_ALWAYS::'
     Return or invoke callback whenever the value changes or the mouse
     button is released.

See demo program 'thumbwheel.c' for an example use of this.


File: xforms.info,  Node: Other Thumbwheel Routines,  Next: Thumbwheel Attributes,  Prev: Thumbwheel Interaction,  Up: Thumbwheel Object

17.7.4 Other Thumbwheel Routines
--------------------------------

To change the value and bounds of a thumbwheel use the following
routines
     double fl_set_thumbwheel_value(FL_OBJECT *obj, double val);
     void fl_set_thumbwheel_bounds(FL_OBJECT *obj, double min, double max);
By default, the minimum value is 0.0, the maximum is 1.0 and the value
is 0.5.

To obtain the current value or bounds of a thumbwheel use
     double fl_get_thumbwheel_value(FL_OBJECT *obj);
     void fl_get_thumbwheel_bounds(FL_OBJECT *obj, double *min, double *max);

By default, the bounds are "hard", i.e., once you reach the minimum or
maximum, the wheel would not turn further in this direction.  However,
if desired, you can make the bounds to turn over such that it crosses
over from the minimum to the maximum value and vice versa.  To this end,
the following routine is available
     int fl_set_thumbwheel_crossover(FL_OBJECT *obj, int yes_no);

In a number of situations you might like thumbwheel values to be rounded
to some values, e.g., to integer values.  To this end use the routine
     void fl_set_thumbwheel_step(FL_OBJECT *obj, double step);
After this call thumbwheel values will be rounded to multiples of
'step'.  Use a value 0.0 for 'step' to switch off rounding.

To get the current setting for this call
     double fl_set_thumbwheel_step(FL_OBJECT *obj);


File: xforms.info,  Node: Thumbwheel Attributes,  Next: Thumbwheel Remarks,  Prev: Other Thumbwheel Routines,  Up: Thumbwheel Object

17.7.5 Thumbwheel Attributes
----------------------------

Setting colors via '*note fl_set_object_color()::' has no effect on
thumbwheels.


File: xforms.info,  Node: Thumbwheel Remarks,  Prev: Thumbwheel Attributes,  Up: Thumbwheel Object

17.7.6 Remarks
--------------

See the demo program 'thumbwheel.c' for an example of the use of
thumbwheels.


File: xforms.info,  Node: Part III Input Objects,  Next: Part III Choice Objects,  Prev: Part III Valuator Objects,  Up: Top

18 Input Objects
****************

It is often required to obtain textual input from the user, e.g., a file
name, some fields in a database, etc.  To this end input fields exist in
the Forms Library.  An input field is a field that can be edited by the
user using the keyboard.

* Menu:

* Adding Input Objects:   Adding Input Objects
* Input Types:            Input Types
* Input Interaction:      Input Interaction
* Other Input Routines:   Other Input Routines
* Input Attributes:       Input Attributes
* Remarks:                Input Remarks


File: xforms.info,  Node: Adding Input Objects,  Next: Input Types,  Up: Part III Input Objects

18.1 Adding Input Objects
=========================

Adding an object To add an input field to a form you use the routine
     FL_OBJECT *fl_add_input(int type, FL_Coord x, FL_Coord y,
                             FL_Coord w, FL_Coord h, const char *label)
The meaning of the parameters is as usual.  The label is by default
placed in front of the input field.


File: xforms.info,  Node: Input Types,  Next: Input Interaction,  Prev: Adding Input Objects,  Up: Part III Input Objects

18.2 Input Types
================

The following types of input fields exist:
'FL_NORMAL_INPUT'
     Any type of text can be typed into this field.

'FL_FLOAT_INPUT'
     Only a floating point numbers can be typed in (e.g., -23.2e12).
     The resulting string will be accepted by 'strtod()' in its entirety
     (but may be too big to be represented by an 'int' or 'long').

'FL_INT_INPUT'
     Only an integers can be typed in (e.g., -86).  The resulting string
     will be accepted by 'strtol()' in its entirety (but may be too big
     to be represented by an 'float' or 'double').

'FL_DATE_INPUT'
     Only a date (MM/DD/YY or DD/MM/YY) can be typed in (and limited per
     default to 10 characters).

'FL_MULTILINE_INPUT'
     An input field allowing for multiple lines.

'FL_SECRET_INPUT'
     A normal input field that does not show the text (and limited per
     default to a maximum length of 16 characters).

'FL_HIDDEN_INPUT'
     A normal input field but invisible.

A normal input field can contain one line of text, to be typed in by the
user.  A float input field can only contain a float number.  If the user
tries to type in something else than a float, it is not shown and the
bell is sounded.  Similarly, an int input field can only contain an
integer number and a date input field can only contain a valid date (see
below).  A multi-line input field can contain multiple lines of text.  A
secret input field works like a normal input field but the text is not
shown (or scrambled).  Only the cursor is shown which does move while
text is being entered.  This can for example be used for getting
passwords.  Finally, a hidden input field is not shown at all but does
collect text for the application program to use.


File: xforms.info,  Node: Input Interaction,  Next: Other Input Routines,  Prev: Input Types,  Up: Part III Input Objects

18.3 Input Interaction
======================

Whenever the user presses the mouse inside an input field a cursor will
appear in it (and the field will change color to indicate that it
received the input focus).  Further input will be directed into this
field.  The user can use the following keys (as in 'emacs(1)') to edit
or move around inside the input field:
delete previous char
     '<Backspace>', '<Ctrl>h'
delete next char
     '<Delete>'
delete previous word
     '<Ctrl><Backspace>'
delete next word
     '<Ctrl><Delete>'
delete from cursor position to end of line
     '<Ctrl>k'
delete from cursor position to begin of line
     '<Meta>h'
jump to begin of line
     '<Ctrl>a'
jump to end of line
     '<Ctrl>e'
move char backward
     '<Ctrl>b'
move char forward
     '<Ctrl>f'
move to next line
     '<Ctrl>n', '<Down>'
move to previous line
     '<Ctrl>p', '<Up>'
move word backward
     '<Meta>b'
move word forward
     '<Meta>f'
move to begin of field
     '<Home>'
move to end of field
     '<End>'
clear input field
     '<Ctrl>u'
paste
     '<Ctrl>y'

It is possible to remap the the bindings, see below for details.

A single click into the input field positions the cursor at the position
of the mouse click.

There are three ways to select part of the input field.  Dragging,
double-click and triple-click.  A double-click selects the word the
mouse is on and a triple-click selects the entire line the mouse is on.
The selected part of the input field is removed when the user types the
'<Backspace>' or '<Delete>' key or replaced by what the user types in.

One additional property of selecting part of the text field is that if
the selection is done with the left mouse button the selected part
becomes the primary ('XA PRIMARY') selection of the X Selection
mechanism, thus other applications, e.g., 'xterm', can request this
selection.  Conversely, the cut-buffers from other applications can be
pasted into the input field.  Use the middle mouse button for pasting.
Note that '<Ctrl>y' only pastes the cut-buffer generated by '<Ctrl>k'
and is not related to the X Selection mechanism, thus it only works
within the same application.  When the user presses the '<Tab>' key the
input field is returned to the application program and the input focus
is directed to the next input field.  This also happens when the user
presses the '<Return>' key but only if the form does not contain a
return button.  The order which input fields get the focus when the
'<Tab>' is pressed is the same as the order the input fields were added
to the form.  From within Form Designer, using the raising function you
can arrange (re-arrange) the focus order, see *note Raising and
Lowering::, in Part II for details.  If the '<Shift>' key is pressed
down when the '<Tab>' is pressed, the focus is directed to the previous
input field.

Leaving an input field using the '<Return>') key does not work for
multi-line input fields since the '<Return>' key is used to start a new
line.

Per default the input object gets returned to the application (or the
callback set for the input object is invoked) when the input field is
left and has been changed.  Depending on the application, other options
might be useful.  To change the precise condition for the object to be
returned (or its callback to become invoked), the '*note
fl_set_object_return()::' function can be used with one of the following
values:
'*note FL_RETURN_NONE::'
     Never return or invoke callback

'*note FL_RETURN_END_CHANGED::'
     Default, object is returned or callback is called at the end if the
     field had been modified.

'*note FL_RETURN_CHANGED::'
     Return or invoke the callback function whenever the field had been
     changed.

'*note FL_RETURN_END::'
     Return or invoke the callback function at the end regardless if the
     field was modified or not.

'*note FL_RETURN_ALWAYS::'
     Return or invoke the callback function upon each keystroke and at
     the end (regardless if the field was changed or not)

See demo 'objreturn.c' for an example use of this.

A few additional notes: when you read "the fields has been changed" this
includes the case that the user e.g., deleted a character and then added
it back again.  Also this case is reported as a "change" (a delete alone
isn't) so the term "changed" does not necessarily mean that the content
of the field has changed but that the user made changes (but which still
might result in the exact same content as before).

Another term that may be understood differently is "end".  In the
versions since 1.0.91 it means that the users either hits the '<Tab>' or
the '<Return>' key (except for multi-line inputs) or that she clicks
onto some other object that in principle allows user interaction.  These
events are interpreted as an indication the user is done editing the
input field and thus are reported back to the program, either by
returning the input object or invoking its callback.  But unless the
user goes to a different input object the input field edited retains the
focus.

Up to version 1.0.90 this was handled a bit differently: an "end of
edit" event was not reported back to the program when the user clicked
on a non-input object, i.e., changed to a different input object.  This
let to some problems when the interaction with the clicked-on non-input
object dependet on the new content of the input object, just having been
edited, but which hadn't been been reported back to the caller.  On the
other hand, some programs rely on the "old" behaviour.  These programs
can switch back to the traditional behaviour by calling the new function
(available since 1.0.93)
     fl_input_end_return_handling(int type);
where 'type' can be either 'FL_INPUT_END_EVENT_ALWAYS', which is now the
default, or 'FL_INPUT_END_EVENT_CLASSIC', which switches back to the
type of handing used in versions up and including to 1.0.90.  The
function can be used at any time to change between the two possible
types of behaviour.  The function returns the previous setting.

There is a routine that can be used to limit the number of characters
per line for input fields of type '*note FL_NORMAL_INPUT::'
     void fl_set_input_maxchars(FL_OBJECT *obj, int maxchars);
To reset the limit to unlimited, set 'maxchars' to 0.  Note that input
objects of type '*note FL_DATE_INPUT::' are limited to 10 characters per
default and those of type '*note FL_SECRET_INPUT::' to 16.

Although an input of type '*note FL_RETURN_ALWAYS::' can be used in
combination with the callback function to check the validity of
characters that are entered into the input field, use of the following
method may simplify this task considerably:
     typedef int (*FL_INPUT_VALIDATOR)(FL_OBJECT *obj, const char *old,
                                      const char *cur, int c);
     FL_INPUT_VALIDATOR fl_set_input_filter(FL_OBJECT *obj,
                                            FL_INPUT_VALIDATOR filter);
The function 'filter()' is called whenever a new (regular) character is
entered.  'old' is the string in the input field before the newly typed
character 'c' was added to form the new string 'cur'.  If the new
character is not an acceptable character for the input field, the filter
function should return 'FL_INVALID' otherwise 'FL_VALID'.  If
'FL_INVALID' is returned, the new character is discarded and the input
field remains unmodified.  The function returns the old filter.  While
the built-in filters also sound the keyboard bell, this doesn't happpen
if a custom filter only returns 'FL_INVALID'.  To also sound the
keyboard bell logically or it with 'FL_INVALID | FL_RINGBELL'.

This still leaves the possibility that the input is valid for every
character entered, but the string is invalid for the field because it is
incomplete.  For example, 12.0e is valid for a float input field for
every character typed, but the final string is not a valid floating
point number.  To guard against such cases the filter function is also
called just prior to returning the object with the argument 'c' (for the
newly entered character) set to zero.  If the validator returns
'FL_INVALID' the object is not returned to the application program, but
input focus can change to the next input field.  If the return value is
'FL_INVALID | FL_RINGBELL' the keyboard bell is sound, the object is
also not returned to the application program and the input focus remains
in the object.

To facilitate specialized input fields using validators, the following
validator dependent routines are available
     void fl_set_input_format(FL_OBJECT *obj, int attrib1, int attrib2);
     void fl_get_input_format(FL_OBJECT *obj, int *attrib1, int *attrib2);
These two routines more or less provide a means for the validator to
store and retrieve some information about user preference or other state
dependent information.  'attrib1' and 'attrib2' can be any validator
defined variables.  For the built-in class, only the one of type '*note
FL_DATE_INPUT::' utilizes these to store the date format: for 'attrib1',
it can take 'FL_INPUT_MMDD' or 'FL_INPUT_DDMM' and 'attrib2' is the
separator between month and day.  For example, to set the date format to
'dd/mm', use
     fl_set_input_format(obj, FL_INPUT_DDMM, '/');
For the built-in type '*note FL_DATE_INPUT::' the default is
'FL_INPUT_MMDD' and the separator is ''/''.  There is no limit on the
year other than it must be an integer and appear after month and day.

The function
     int fl_validate_input(FL_OBJECT *obj);
can be used to test if the value in an input field is valid.  It returns
'*note FL_VALID::' if the value is valid or if there is no validator
function set for the input, otherwise '*note FL_INVALID::'.

There are two slightly different input modes for input objects.  In the
"normal" mode, when the input field is entered not using the mouse
(e.g., by using of the <Tab> key) the cursor is placed again at the
position it was when the field was left (or at the end of a possibly
existing string when it's entered for the first time).  When an input
object has a maximum number of allowed characters set (via the '*note
fl_set_input_maxchars()::' function) and there's no room left no new
input is accepted until at least one character has been deleted.

As an alternative there's an input mode that is similar to the way
things were handle in DOS forms etc.  Here, when the field is entered by
any means but clicking into it with the mouse, the cursor is placed at
the start of the text.  And for fields with a maximum capacity, that
contain already as many characters as possible, the character at the end
of the field are removed when a new one is entered.

To switch between the two modes use the function
where 'mode' is one of
'FL_NORMAL_INPUT_MODE'
     The default.  Use it to switch to the "normal" input mode
'FL_DOS_INPUT_MODE'
     For selecting the DOS-like input mode (in this mode, when a maximum
     number of characters has been set, as many characters already have
     been entered, and a new character is inserted somewhere in the
     middle the character at the very end gets deleted to make room for
     the new character)
The function returns the previous setting.  Note that the function
changes the input mode for all input fields in your application.


File: xforms.info,  Node: Other Input Routines,  Next: Input Attributes,  Prev: Input Interaction,  Up: Part III Input Objects

18.4 Other Input Routines
=========================

Note that the label is not the default text in the input field.  To set
the contents of the input field use one of these routines:
     void fl_set_input(FL_OBJECT *obj, const char *str);
     void fl_set_input_f(FL_OBJECT *obj, const char *fmt, ...);
The first one takes a simple string while the second expects a format
string with format specifiers just like 'printf()' etc.  and as many
(appropriate) arguments as there are format specifiers.

Only a limited check on the string passed to the function is done in
that only printable characters (according to the 'isprint()' function)
and, in the case of '*note FL_MULTILINE_INPUT::' objects, new-lines
(''\n'') are accepted (i.e., all that don't fit are skipped).  Use an
empty string (or a 'NULL' pointer as the second argument) to clear an
input field.

Setting the content of an input field does not trigger an object event,
i.e., the object callback is not called.  In some situations you might
want to have the callback invoked.  For this, you may use the function
'*note fl_call_object_callback()::'.

To obtain the string in the field (when the user has changed it) use:
     const char *fl_get_input(FL_OBJECT *obj);
This function returns a char pointer for all input types.  Thus for
numerical input types e.g., 'strtol(3)', 'atoi(3)', 'strtod(3)',
'atof(3)' or 'sscanf(3)' should be used to convert the string to the
proper data type you need.  For multiline input, the returned pointer
points to the entire content with possibly embedded newlines.  The
application may not modify the content pointed to by the returned
pointer, it points to the internal buffer.

To select or deselect the current input or part of it, the following two
routines can be used
     void fl_set_input_selected(FL_OBJECT *obj, int flag);
     void fl_set_input_selected_range(FL_OBJECT *obj, int start, int end);
where 'start' and 'end' are measured in characters.  When 'start' is 0
and 'end' equals the number of characters in the string, '*note
fl_set_input_selected()::' makes the entire input field selected.
However, there is a subtle difference between this routine and '*note
fl_set_input_selected()::' when called with 'flag' set to 1: '*note
fl_set_input_selected()::' always places the cursor at the end of the
string while '*note fl_set_input_selected_range()::q' places the cursor
at the beginning of the selection.

To obtain the currently selected range, either selected by the
application or by the user, use the following routine
     const char *fl_get_input_selected_range(FL_OBJECT *obj,
                                             int *start, int *end);
where 'start' and 'end', if not 'NULL', are set to the begining and end
position of the selected range, measured in characters.  For example, if
'start' is 5 after the function returned and 'end' is 7, it means the
selection starts at character 6 ('str[5]') and ends before character 8
('str[7]'), so a total of two characters are selected (i.e., character 6
and 7).  The function returns the selected string (which may not be
modified).  If there is currently no selection, the function returns
'NULL' and both 'start' and 'end' are set to -1.  Note that the 'char'
pointer returned by the function points to (kind of) a static buffer,
and will be overwritten by the next call.

It is possible to obtain the cursor position using the following routine
     int fl_get_input_cursorpos(FL_OBJECT *obj, int *xpos, int *ypos);
The function returns the cursor position measured in number of
characters (including newline characters) in front of the cursor.  If
the input field does not have input focus (thus does not have a cursor),
the function returns -1.  Upon function return, 'ypos' is set to the
number of the line (starting from 1) the cursor is on, and 'xpos' set to
the number of characters in front of the cursor measured from the
beginning of the current line as indicated by 'ypos'.  If the input
field does not have input focus the 'xpos' is set to -1.

It is possible to move the cursor within the input field
programmatically using the following routine
     void fl_set_input_cursorpos(FL_OBJECT *obj, int xpos, int ypos);
where 'xpos' and 'ypos' are measured in characters (lines).  E.g., given
the input field '"an arbitrary string"' the call
     fl_set_input_cursorpos(ob, 4, 1);
places the the cursor after the first character of the word
'"arbitrary"', i.e., directly after the first 'a'.

By default, if an input field of type '*note FL_MULTILINE_INPUT::'
contains more text than can be shown, scrollbars will appear with which
the user can scroll the text around horizontally or vertically.  To
change this default, use the following routines
     void fl_set_input_hscrollbar(FL_OBJECT *obj, int how);
     void fl_set_input_vscrollbar(FL_OBJECT *obj, int how);
where 'how' can be one of the following values
'FL_AUTO'
     The default.  Shows the scrollbar only if needed.
'FL_ON'
     Always shows the scrollbar.
'FL_OFF'
     Never show scrollbar.
Note however that turning off scrollbars for an input field does not
turn off scrolling, the user can still scroll the field using cursor and
other keys.

To completely turn off scrolling for an input field (for both multiline
and single line input field), use the following routine with a false
value for 'yes_no'
     void fl_set_input_scroll(FL_OBJECT *obj, int yes_no);

There are also routines that can scroll the input field
programmatically.  To scroll vertically (for input fields of type '*note
FL_MULTILINE_INPUT::' only), use
     void fl_set_input_topline(FL_OBJECT *obj, int line);
where 'line' is the new top line (starting from 1) in the input field.
To programmatically scroll horizontally, use the following routine
     void fl_set_input_xoffset(FL_OBJECT *obj, int pixels);
where 'pixels', which must be a positive number, indicates how many
pixels to scroll to the left relative to the nominal position of the
text lines.

To obtain the current xoffset, use
     int fl_get_input_xoffset(FL_OBJECT *obj);

It is possible to turn off the cursor of the input field using the
following routine with a false value for 'yes_no':
     void fl_set_input_cursor_visible(FL_OBJECT *obj, int yes_no);

To obtain the number of lines in the input field, call
     int fl_get_input_numberoflines(FL_OBJECT *obj);

To obtain the current topline in the input field, use
     int fl_get_input_topline(FL_OBJECT *obj);

To obtain the number of lines that fit inside the input box, use
     int fl_get_input_screenlines(FL_OBJECT *obj);

For secret input field, the default is to draw the text using spaces.
To change the character used to draw the text, the following function
can be used
     int fl_set_input_fieldchar(FL_OBJECT *obj, int field_char);
The function returns the old field char.


File: xforms.info,  Node: Input Attributes,  Next: Input Remarks,  Prev: Other Input Routines,  Up: Part III Input Objects

18.5 Input Attributes
=====================

Never use '*note FL_NO_BOX::' as the boxtype.

The first color argument ('col1') to '*note fl_set_object_color()::'
controls the color of the input field when it is not selected and the
second ('col2') is the color when selected.

To change the color of the input text or the cursor use
     void fl_set_input_color(FL_OBJECT *obj, FL_COLOR tcol, FL_COLOR ccol);
Here 'tcol' indicates the color of the text and 'ccol' is the color of
the cursor.

If you want to know the colors of the text and cursor use
     void fl_get_input_color(FL_OBJECT *obj, FL_COLOR *tcol, FL_COLOR *ccol);

By default, the scrollbar size is dependent on the initial size of the
input box.  To change the size of the scrollbars, use the following
routine
     void fl_set_input_scrollbarsize(FL_OBJECT *obj, int hh, int vw);
where 'hh' is the horizontal scrollbar height and 'vw' is the vertical
scrollbar width in pixels.

To determine the current settings for the horizontal scrollbar height
and the vertical scrollbar width use
     void fl_get_input_scrollbarsize(FL_OBJECT *obj, int *hh, int *vw);

The default scrollbar types are '*note FL_HOR_THIN_SCROLLBAR::' and
'*note FL_VERT_THIN_SCROLLBAR::'.  There are two ways you can change the
default.  One way is to use '*note fl_set_defaults()::' or '*note
fl_set_scrollbar_type()::' to set the application wide default
(preferred); another way is to use '*note fl_get_object_component()::'
to get the object handle to the scrollbars and change the the object
type forcibly.  Although the second method of changing the scrollbar
type is not recommended, the object handle obtained can be useful in
changing the scrollbar colors etc.

As mentioned earlier, it is possible for the application program to
change the default edit keymaps.  The editing key assignment is held in
a structure of type 'FL_EditKeymap' defined as follows:
     typedef struct {
         long del_prev_char;     /* delete previous char */
         long del_next_char;     /* delete next char */
         long del_prev_word;     /* delete previous word */
         long del_next_word;     /* delete next word */
         long del_to_eol;        /* delete from cursor to end of line */
         long del_to_bol;        /* delete from cursor to begin of line */
         long clear_field;       /* delete all */
         long del_to_eos;        /* not implemented */
         long backspace;         /* alternative for del_prev_char */

         long moveto_prev_line;  /* one line up */
         long moveto_next_line;  /* one line down */
         long moveto_prev_char;  /* one char left */
         long moveto_next_char;  /* one char right */
         long moveto_prev_word;  /* one word left */
         long moveto_next_word;  /* one word right */
         long moveto_prev_page;  /* one page up */
         long moveto_next_page;  /* one page down */
         long moveto_bol;        /* move to begining of line */
         long moveto_eol;        /* move to end of line */
         long moveto_bof;        /* move to begin of file */
         long moveto_eof;        /* move to end of file */

         long transpose;         /* switch two char positions*/
         long paste;             /* paste the edit buffer */
     } FL_EditKeymap;

To change the default edit keymaps, the following routine is available:
     void fl_set_input_editkeymap(const FL_EditKeymap *km);
with a filled or partially filled '*note FL_EditKeymap::' structure.
The unfilled members must be set to 0 so the default mapping is
retained.  Change of edit keymap is global and affects all input field
within the application.

Calling '*note fl_set_input_editkeymap()::' with 'km' set to 'NULL'
restores the default.  All cursor keys ('<Left>', '<Home>' etc.)  are
reserved and their meanings hard-coded, thus can't be used in the
mapping.  For example, if you try to set 'del_prev_char' to '<Home>',
pressing the '<Home>' key will not delete the previous character.

To obtain the current map of the edit keys use the function
     void fl_get_input_editkeymap(FL_EditKeymap *km);
with the 'km' argument pointing of a user supplied structure which after
the call will be set up with the current settings for the edit keys.

In filling the keymap structure, ASCII characters (i.e., characters with
values below 128, including the control characters with values below 32)
should be specified by their ASCII codes ('<Ctrl> C' is 3 etc.), while
all others by their 'Keysym's ('XK_F1' etc.).  Control and special
character combinations can be obtained by adding 'FL_CONTROL_MASK' to
the 'Keysym'.  To specify 'Meta' add 'FL_ALT_MASK' to the key value.

     FL_EditKeymap ekm;
     memset(&ekm, 0, sizeof ekm);                  /* zero struct */

     ekm.del_prev_char = 8;                        /* <Backspace> */
     ekm.del_prev_word = 8 | FL_CONTROL_MASK;      /* <Ctrl><Backspace> */
     ekm.del_next_char = 127;                      /* <Delete> */
     ekm.del_prev_word = 'h' | FL_ALT_MASK;        /* <Meta>h */
     ekm.del_next_word = 127 | FL_ALT_MASK;        /* <Meta><Delete> */
     ekm.moveto_bof    = XK_F1;                    /* <F1> */
     ekm.moveto_eof    = XK_F1 | FL_CONTROL_MASK;  /* <Ctrl><F1> */

     fl_set_input_editkeymap(&ekm);

Note: In earlier versions of XForms (all version before 1.2) the default
behaviour of the edit keys was slightly different which doesn't fit
modern user expectations, as was the way the way the edit keymap was to
be set up.  If you use XForms for some older application that makes
massive use of the "classical" behaviour you can compile XForms to use
the old behaviour by using the '--enable-classic-editkeys' option when
configuring the library for compilation.


File: xforms.info,  Node: Input Remarks,  Prev: Input Attributes,  Up: Part III Input Objects

18.6 Remarks
============

Always make sure that the input field is high enough to contain a single
line of text.  If the field is not high enough, the text may get
clipped, i.e., become unreadable.

See the program 'demo06.c' for an example of the use of input fields.
See 'minput.c' for multi-line input fields.  See 'secretinput.c' for
secret input fields and 'inputall.c' for all input fields.


File: xforms.info,  Node: Part III Choice Objects,  Next: Part III Container Objects,  Prev: Part III Input Objects,  Up: Top

19 Choice Objects
*****************

* Menu:

* Select Object:   Select Object
* Nmenu Object:    Nmenu Object
* Browser Object:  Browser Object


File: xforms.info,  Node: Select Object,  Next: Nmenu Object,  Up: Part III Choice Objects

19.1 Select Object
==================

A select object is a rather simple object that allows the user to pick
alternatives from a linear list that pops up when he clicks on the
object.  It remembers the last selected item, which is also shown on top
of the select object.

The select object internally uses a popup (*note Part III Popups::) and
thus it can be helpful to understand at lest some aspects of how popups
work to fully grasp the functionality of select objects.

* Menu:

* Adding Select Objects:   Adding Select Objects
* Select Interaction:      Select Interaction
* Other Select Routines:   Other Select Routines
* Select Attributes:       Select Attributes
* Remarks:                 Select Remarks


File: xforms.info,  Node: Adding Select Objects,  Next: Select Interaction,  Up: Select Object

19.1.1 Adding Select Objects
----------------------------

To add a select object to a form use
     FL_OBJECT *fl_add_select(int type, FL_Coord x, FL_Coord y,
                              FL_Coord w, FL_Coord h, const char *label)
There are currently three types which just differ by the way they look:
'FL_NORMAL_SELECT'
     Per default this type is drawn as a rounded, flat box (but you can
     change that by setting a different boxtype for the object) with the
     text of the currently selected item in its center.

'FL_MENU_SELECT'
     This select object looks like a button with a little extra box at
     its right side (just like a 'FL_MENU_BUTTON') and the text of the
     currently selected item is drawn on the button-like object.

'FL_DROPLIST_SELECT'
     This type looks like a button with the text of the currently
     selected item on top of it and a second square button directly
     beside it with an downward pointing arrow on it.

Per default 'label' is drawn outside and to the left of the object.

Once a new select object has been created items have to be added to it.
For this the following function exists:
     FL_POPUP_ENTRY *fl_add_select_items(FL_OBJECT *obj,
                                         const char items,...);
'items' is a string with the items to add, separated by the '|'
character.  In the simplest case you would just use something like
'"Item 1|Item 2|Item 3"' to add three items to the list.  If there
weren't any items before the first item will be automatically shown as
the selected one.

As also described in the documentation for the similar function '*note
fl_popup_add_entries()::' (*note Adding Popups::) the text for an item
may contain "special sequences" that start with the character '%' and
the may require an additional argument passed to the function after the
'items' argument:
'%x'
     Set a value of type 'long int' that's passed to all callback
     routines for the item.  The value must be given in the arguments
     following the 'items' string.

'%u'
     Set a 'user_void' pointer that's passed to all callbacks of the
     item.  The pointer must be specified in the arguments following the
     'items' string.

'%f'
     Set a callback function that gets called when the item is selected.
     The function is of type
          int callback(FL_POPUP_RETURN *r);
     Information about the item etc. gets passed to the callback
     function via the '*note FL_POPUP_RETURN::' structure and the return
     value of the function can be used to keep the selection from
     becoming reported back to the user made by returning a value of
     'FL_IGNORE' (-1).  The function's address must be given in the
     arguments following the 'items' string.

'%E'
     Set a callback routine that gets called each time the mouse enters
     the item (as long as the item isn't disabled or hidden).  The type
     of the function is the same as that of the callback function for
     the selection of the item but it's return value is never used.  The
     functions address must be given in the arguments following the
     'items' string.

'%L'
     Set a callback routine that gets called each time the mouse leaves
     the item.  The type of the function is the same that as of the
     callback function for the selection of the item but it's return
     value is never used.  The functions address must be given in the
     arguments following the 'items' string.

'%d'
     Marks the item as disabled, i.e., it can't be selected and its text
     is per default drawn in a different color

'%h'
     Marks the item as hidden, i.e., it is not shown while in this
     state.

'%S'
     For items with shortcut keys it's quite common to have them shown
     on the right hand side.  Using '"%S"' you can split the items text
     into two parts, the first one (before '"%S"') being drawn flushed
     left and the second part flushed right.  Note that using this
     special sequence doesn't automatically sets a shortcut key, this
     still has to be done using '"%s"'.

'%s'
     Sets one or more shortcut keys for an item.  Requires a string with
     the shortcuts in the arguments following the 'items' string.  *Note
     Shortcuts::, for details on how to define shortcuts.  Please note
     that the character in the label identical to the shortcut character
     is only shown as underlined if '"%S"' isn't used.

'%%'
     Use this to get a ''%'' within the text of an item.
If you compare this list of "special sequences" with those listed for
the '*note fl_popup_add_entries()::' function you will find that aome
are missing.  This is because a select object is a simple linear list of
items that uses only parts of the popups functionalities.

Another way to set up the popup of a select object is to use the
function
     long fl_set_select_items(FL_OBJECT *obj, FL_POPUP_ITEM *item);
Here 'item' is an array of structures of type '*note FL_POPUP_ITEM::'
with the 'text' member of the very last element of the array being set
to 'NULL', indicating the end of the array.

The 'text' member is the text of the item.  It may only contain one
"special sequence", '"%S"' to indicate that the string is to be split at
that position into the part of the item label to be drawn to the left
and on the right side (also prepending the string with ''_'' or ''/''
has no effect).  'callback' is a callback function to be invoked on
selection of the item.  'shortcut' is a string for setting keybord
shortcuts for the item.  'type' has no function at all here (there can
be only items of type '*note FL_POPUP_NORMAL::' in a select objects
popup) and 'state' can be set to '*note FL_POPUP_DISABLED::' and/or
'*note FL_POPUP_HIDDEN::'.

Please note: when the select object already had items before the call of
'*note fl_set_select_items()::' then they are removed before the new
ones are set.  The values assigned to the items start at 0.

A third way to "populate" a select object is to create a popup directly
and then associate it with the select object using
     int fl_set_select_popup(FL_OBJECT *obj, FL_POPUP *popup);
If the select object already had a popup before this will be deleted and
replaced by the new popup passed as the second argument.  Please note
that the popup the argument 'popup' points to may not contain any
entries other than those of type '*note FL_POPUP_NORMAL::' (and, of
course, the popup can't be a sub-popup of another popup).


File: xforms.info,  Node: Select Interaction,  Next: Other Select Routines,  Prev: Adding Select Objects,  Up: Select Object

19.1.2 Select Interaction
-------------------------

The simplest interaction with a select object consists of clicking onto
the object and then selecting an item in the popup that gets shown
directly beside the mouse position.

If you click with the left or right mouse button onto the select object
previous or next item, respectively, will be selected.  If youl keep the
left or mouse button pressed down for a longer time slowly all
alternatives are selected, one after each other.

You finally can also use the scroll wheel of your mouse to select the
next or previous item (scrolling down selects the next, scrolling up the
previous item).

On every selection of an item (also if the already selected item is
re-selected) a callback that may have been associated with the item is
executed.  The callback receives as its argument a pointer to a
structure of type '*note FL_POPUP_RETURN::'.

Its 'val' member is a integer value associated with the entry.  It can
be set explicitely on creation of the item using the '"%x"' "special
sequence".  If not given then first item gets the value 0, the next 1
etc.  'user_data' is a pointer to some user data, which can be set on
creation of the item using '"%u"'.  'text' is the string used in
creating the item, including all "special sequences", while 'label' is
the string shown in the popup for the item.  If there was a special
sequence of '"%S"' in the string that was used to create the item
'accel' is the text that appears right-flushed in the popup for the
item.  'entry' is a pointer to the popup entry that represents the item
in the select object and, finally, 'popup' is the popup associated with
the select object.

Normally, when a new item is selected this is reported back to the
caller either by calling the select objects callback (if one exists) or
by returning the object as the result of a call of e.g., '*note
fl_do_forms()::'.  But if the callback for the item itself returns
'FL_IGNORE' then the latter doesn't happen.  This can be useful for
cases where all work for a change of the selection can already be done
within the items callback and the "main loop" shouldn't get involved
anymore.

As for all other normal objects the condition under which a 'FL_SELECT'
object gets returned to the application (or an associate callback is
called) can be influenced by calling the function
     int fl_set_object_return(FL_OBJECT *obj, unsigned int when)
where 'when' can have the following values
'*note FL_RETURN_NONE::'
     Never return or invoke a callback.

'*note FL_RETURN_END_CHANGED::'
     Return or invoke callback if end of interaction and selection of an
     item coincide.

'*note FL_RETURN_CHANGED::'
     Return or invoke callback whenever an item is selected (this is the
     default).

'*note FL_RETURN_END::'
     Return or invoke callback on end of an interaction.

'*note FL_RETURN_ALWAYS::'
     Return (or invoke callback) whenever the interaction ends and/or an
     item is selected.

Per default the popup of a select objects remains shown when the user
releases the mouse somewhere outside the popup window (or on its title
area).  The alternative is to close the popup immediately when the user
releases the mouse, independent of where it is.  Using the function
     int fl_set_select_policy(FL_OBJECT *obj, int policy);
the program can switch between these two modes of operation, where
'policy' can be on of two values:
'FL_POPUP_NORMAL_SELECT'
     Keeps the popup opened when the mouse isn't released on one of the
     selectable items.

'FL_POPUP_DRAG_SELECT'
     Close the popup immediately when the mouse button is released.
The function returns on success the previous setting of the "policy" and
-1 on error.


File: xforms.info,  Node: Other Select Routines,  Next: Select Attributes,  Prev: Select Interaction,  Up: Select Object

19.1.3 Other Select Routines
----------------------------

To find out which item is currently selected use
     FL_POPUP_RETURN *fl_get_select_item(FL_OBJECT *obj);
It returns a pointer to a structure of type '*note FL_POPUP_RETURN::' as
already described above, containing all needed information about the
selected item.

For some actions, e.g., deletion of an item etc., it is necessary to
know the popup entry that represents it.  Therefore it's possible to
search the list of items according to several criteria:
     FL_POPUP_ENTRY *fl_get_select_item_by_value(FL_OBJECT *obj, long val);
     FL_POPUP_ENTRY *fl_get_select_item_by_label(FL_OBJECT *obj,
                                                 const char *label);
     FL_POPUP_ENTRY *fl_get_select_item_by_label_f(FL_OBJECT *obj,
                                                   const char *fmt, ...);
     FL_POPUP_ENTRY *fl_get_select_item_by_text(FL_OBJECT *obj,
                                                const char *text);
     FL_POPUP_ENTRY *fl_get_select_item_by_text_f(FL_OBJECT *obj,
                                                  const char *fmt, ...);
The first function, '*note fl_get_select_item_by_value()::', searches
through the list of items and returns the first one with the 'val'
associated with the item (or 'NULL' if none is found).  The second and
third, '*note fl_get_select_item_by_label()::' and '*note
fl_get_select_item_by_label_f()::' searches for a certain label as
displayed for the item in the popup.  The last two, '*note
fl_get_select_item_by_text()::' and '*note
fl_get_select_item_by_text_f()::' searches for the text the item was
created by (that might be the same as the label text in simple cases).
The difference between the second and third and the forth and the last
is the way the text is passed to the functions, it's either a simple
string or the result of the expansion of a format string as used for
'printf()' etc.  using the following unspecified arguments.

Please note that all these functions return a structure of type '*note
FL_POPUP_ENTRY::' (and not '*note FL_POPUP_RETURN::', which gives you
direct access to the entry in the popup for the item.

Using e.g., the result of one of the functions above you can also set
the currently selected item via your program using
     FL_POPUP_RETURN *fl_set_select_item(FL_OBJECT *obj,
                                         FL_POPUP_ENTRY *entry);

Or you could use the result to delete an item:
     int fl_delete_select_item(FL_OBJECT *obj, FL_POPUP_ENTRY *entry);
Please note that the values associated with items won't change due to
removing an item.

Alternatively, you can replace an item by one or more new ones.  To do
that use
     FL_POPUP_ENTRY *fl_replace_select_item(FL_OBJECT *obj,
                                            FL_POPUP_ENTRY *old,
                                            const char *new_items, ...);
'old' designates the item to be removed and 'new_items' is a string
exactly like it would be used in '*note fl_add_select_items()::' for the
'items' argument, that defines the item(s) to replace the existing item.
Please note that, unless values to be associated with the items (see the
'val' member of the '*note FL_POPUP_RETURN::' structure) there's a twist
here.  When items get created they per default receive increasing
values, starting at 0.  This also holds for items that get created in
the process of replacement.  The result is that the ordering of those
values in that case wont represent the order in which they appear in the
select objects popup.

Another sometimes useful function allows insertion of new items
somewhere in the middle of a list of already existing items:
     FL_POPUP_ENTRY *fl_insert_select_items(FL_OBJECT *obj,
                                            FL_POPUP_ENTRY *after,
                                            const char *new_items, ...);
'after' is the entry after which the new item(s) are to be inserted (if
it's 'NULL' the new items are inserted at the very start).  The rest of
the arguments are the same as for '*note fl_replace_select_item()::' and
the same caveats about the values associated automatically with the new
items holds.

It's possible to remove all items from a select object by calling
     int fl_clear_select(FL_OBJECT *obj);
Afterwards you have to call again e.g., '*note fl_add_select_items()::'
to set new entries.  Note that if you used '*note
fl_set_select_popup()::' to set a popup for the select object then that
popup gets deleted automatically on calling '*note fl_clear_select()::'!
The values automatically associated with items when calling '*note
fl_add_select_items()::' will start at 0 again.


File: xforms.info,  Node: Select Attributes,  Next: Select Remarks,  Prev: Other Select Routines,  Up: Select Object

19.1.4 Select Attributes
------------------------

The two color arguments, 'clo1' and 'col2', of the function '*note
fl_set_object_color()::' set the background color of the object normally
and when the mouse is hovering over it, respectively.

With the functions
     FL_COLOR fl_set_selection_text_color(FL_OBJECT *obj, FL_COLOR color);
     FL_COLOR fl_get_selection_text_color(FL_OBJECT *obj);
the color of the text of the currently selected item on top of the
object can be set or queried.

To control (or determine) the alignment of the text with the currently
selected item on top of the select object use
     int fl_set_select_text_align(FLOBJECT *obj, int align);
     int fl_get_select_text_align(FLOBJECT *obj);
Please note that the '*note FL_ALIGN_INSIDE::' flag should be set with
'align' since the text always will be drawn within the boundaries of the
object.  On success the function return the old setting for the
alignment or -1 on error.

Finally, the font style and size of the text can be set or obtained
using
     int fl_set_select_text_font(FL_OBJECT *obj, int style, int size);
     int fl_get_select_text_font(FL_OBJECT *obj, int *style, int *size);

The rest of the appearance of a select object concerns the popup that is
used.  To avoid bloating the API unnecessarily no functions for select
objects were added that would just call popup functions.  The popup
belonging to a select object can be easily found from either a '*note
FL_POPUP_ENTRY::' structure as returned by the functions for searching
for items or the '*note FL_POPUP_RETURN::' structure passed to all
callbacks and also returned by '*note fl_get_select_item()::'.  Both
structures have a member called 'popup' that is a pointer to the popup
associated with the select object.  For popup functions operation on
indiviual items just use the pointer to the '*note FL_POPUP_ENTRY::'
structure itself or the 'entry' member of the '*note FL_POPUP_RETURN::'
structure.

There's also a convenience function for finding out the popup used for a
select object:
     FL_POPUP *fl_get_select_popup(FL_OBJECT *obj);
During the lifetime of a select object the popup never changes as long
as '*note fl_set_select_popup()::' isn't called.

Per default the popup of a select object does not have a title drawn on
top of it.  To change that use '*note fl_popup_set_title()::'.

To change the various colors and fonts used when drawing the popup use
the functions '*note fl_popup_set_color()::' and '*note
fl_popup_entry_set_font()::' (and '*note fl_popup_set_title_font()::').

To change the border width or minimum width of the popup use '*note
fl_popup_set_bw()::' and '*note fl_popup_set_min_width()::'.

To disable or hide (or do the reverse) an item use the functions '*note
fl_popup_entry_set_state()::' and '*note fl_popup_entry_get_state()::'.

The keyboard shortcut for an entry can be set via '*note
fl_popup_entry_set_shortcut()::'.

The callback functions (selection, enter and leave callback) for
individual items can be set via '*note fl_popup_entry_set_callback()::',
'*note fl_popup_entry_set_enter_callback()::' and '*note
fl_popup_entry_set_leave_callback()::', a callback for the whole popup
with '*note fl_popup_set_callback()::'.

Finally, to assign a different (long) value to an item or set a pointer
to user data use '*note fl_popup_entry_set_value()::' and '*note
fl_popup_entry_set_user_data()::'.


File: xforms.info,  Node: Select Remarks,  Prev: Select Attributes,  Up: Select Object

19.1.5 Remarks
--------------

See the demo program 'select.c' for an example of the use of select
objects.


File: xforms.info,  Node: Nmenu Object,  Next: Browser Object,  Prev: Select Object,  Up: Part III Choice Objects

19.2 Nmenu Object
=================

Another object type that heavily depends on popups is the "nmenu" object
type.  It is meant to be used for menus and the "n" in front of the name
stands for "new" since this is a re-implementation of the old menu
object type (which is now deprecated since it is based on *note
XPopup::).

* Menu:

* Adding Nmenu Objects:   Adding Nmenu Objects
* Nmenu Interaction:      Nmenu Interaction
* Other Nmenu Routines:   Other Nmenu Routines
* Nmenu Attributes:       Nmenu Attributes
* Remarks:                Nmenu Remarks


File: xforms.info,  Node: Adding Nmenu Objects,  Next: Nmenu Interaction,  Up: Nmenu Object

19.2.1 Adding Nmenu Objects
---------------------------

To add a nmenu object use
     FL_OBJECT *fl_add_nmenu(int type, FL_Coord x, FL_Coord y,
                             FL_Coord w, FL_Coord h, const char *label);
There are currently three types:
'FL_NORMAL_NMENU'
     Probably the most often used type: shown as text on a borderless
     background, popup gets opened when clicked on.

'FL_NORMAL_TOUCH_NMENU'
     Also shown as text on a borderless background, but popup gets
     opened when the mouse is moved on top of it without any further
     user action required.

'FL_BUTTON_NMENU'
     When not active shown as text on borderless background, when
     clicked on popup is shown and the object itself being displayed as
     a button.

'FL_BUTTON_TOUCH_NMENU'
     When not active shown as text on borderless background, when mouse
     is moved onto it the popup is shown and the object itself is
     displayed as a button.

Once a new nmenu object has been created items have to be added to it.
For this the following function exists:
     FL_POPUP_ENTRY *fl_add_nmenu_items(FL_OBJECT *obj,
                                        const char items, ...);
(The function can also be used to append new items to a nmenu object
that already has items.)

The function returns a pointer to the first menu entry added on success
and 'NULL' on failure.  'items' is a string with the items to add,
separated by the ''|'' character.  In the simplest case you would just
use something like '"Item 1|Item 2|Item 3"' to add three items to the
list.

As also described in the documentation for the similar function '*note
fl_popup_add_entries()::' the text for an item may contain "special
sequences" that start with the character ''%'' and then may require an
additional argument passed to the function after the 'items' argument.
All of those described in detail in the documentation for the '*note
fl_popup_add_entries()::' function can also be used for nmenus.

Another way to set up the popup of a select object, using an array of
*note FL_POPUP_ITEM:: structures, is via the function
     FL_POPUP_ENTRY *fl_set_nmenu_items(FL_OBJECT *obj, FL_POPUP_ITEM *item);
The function returns a pointer to the first menu item on success and
'NULL' on failure.  The function expects as arguments a pointer to the
nmenu object and an array of '*note FL_POPUP_ITEM::' structuress, with
the very last element having 'NULL' as the 'text' member to mark the end
of the array.

The 'text' member of the structure may contain the character sequence
'"%S"' to have the text drawn for the item split up at that position and
with everything before '"%S"' drawn left-flushed and the rest
right-flushed.  Moreover, 'text' may start with the character ''/''
and/or ''_''.  For an underline character a line is drawn above the
item.  And if there's a slash this item marks the begin of a sub-menu
with all further items belonging to the sub-menu until a structure with
member 'text' being set to 'NULL' is found in the array.  (The ''/'' and
''_'' characters are, of course, not drawn.)

'type' indicates the type of the item.  It can be
'FL_POPUP_NORMAL'
     A normal, plain item.

'FL_POPUP_TOGGLE'
     An item that represents one of two states and is drawn with a
     check-marker when in "on" state.

'FL_POPUP_RADIO'
     A radio item, i.e., it belongs to a group of items of which only
     one can be in "on" state at a time.  They are drawn with a circle
     to the left with the circle for the "selected" item being filled
     with a color.
Please note that if 'text' starts with a ''/'' the type *must* be
'FL_POPUP_NORMAL'.

The 'state' member per default is '*note FL_POPUP_NONE::'.  It can be
set to
'FL_POPUP_NONE'
     No special flags are set for the state of the item.

'FL_POPUP_DSABLED'
     The item is disabled and can't be selected.

'FL_POPUP_HIDDEN'
     The item is hidden, i.e., does not get shown (and thus can't be
     selected).

'FL_POPUP_CHECKED'
     Only relevant for toggle or radio items, marks it as in "on" state.

'callback' is a function that will be called if the item is selected.
The callback function has the following type:
     typedef int (*FL_POPUP_CB)(FL_POPUP_RETURN *);
It receives a pointer to a structure that contains all information about
the entry selected by the user:
     typedef struct {
         long int              val;       /* value assigned to entry */
         void                 *user_data; /* pointer to user data */
         const char           *text;      /* text of selected popup entry */
         const char           *label;     /* text drawn on left side */
         const char           *accel;     /* text drawn on right side */
         const FL_POPUP_ENTRY *entry;     /* selected popup entry */
         const FL_POPUP       *popup;     /* (sub-)popup it belongs to */
     } FL_POPUP_RETURN;
'val' is a value that has been associated with the entry and 'user_data'
is a pointer that can be used to store the location of further
information.  'text' is the text that was used to create the entry
(including all "special" characters), while 'label' and 'accel' are the
texts shown for the entry on the left and right.  'entry' is the pointer
to the structure for the entry selected and 'popup' to the (sub-) popup
the entry belongs to (*note Part III Popups:: for more details on these
structures).

If the callback function already does all the work required on selection
of the item have it return the value 'FL_IGNORE' to keep the selection
from being reported back to the main loop of the program.

Finally, 'shortcut' is a string encoding the keybord shortcut to be used
for the item.

There's also a third method to "populate" a menu.  If you already
created a popup than you can set it as the menu's popup via a call of
     int fl_set_nmenu_popup(FL_POPUP *popup);
Of course, the popup you associate with the nmenu object in this way
can't be a sub-popup.


File: xforms.info,  Node: Nmenu Interaction,  Next: Other Nmenu Routines,  Prev: Adding Nmenu Objects,  Up: Nmenu Object

19.2.2 Nmenu Interaction
------------------------

There are, if seen interaction-wise, two types of nmenu objects, normal
ones and touch nmenus.  For normal nmenus a popup is opened when the
user clicks on the area of the nmenu object while for touch nmenus the
popup already is shown when the user moves the mouse unto the area.  In
other respects they behave identical: the user just selects one of the
items in the popup (or one of the sub-popups) and then the popup is
closed again.  The selection can now be handled within a callback
function and/or reported back to the main loop of the program.

The popup is always shown directly below the nmenu object (except for
the case that the popup is that long that it wouldn't fit on the screen,
in which case the popup is drawn above the nmenu's area.

The most natural way to deal with a selection by the user is probably
via a callback for the item that was selected.  But also a callback for
the popup as a whole or the object itself can be used.  Item and popup
callback functions are of type '*note FL_POPUP_CB::' described above
(and in even more detail in *note Part III Popups::), while object
callbacks are "normal" XForms callback functions.

The condition under which a 'FL_NMENU' object gets returned to the
application (or an associate callback is invoked) can be influenced by
calling the function
     int fl_set_object_return(FL_OBJECT *obj, unsigned int when)
where 'when' can have the following values
'*note FL_RETURN_NONE::'
     Never return or invoke a callback.

'*note FL_RETURN_END_CHANGED::'
     Return or invoke callback if end of interaction and selection of an
     item coincide.

'*note FL_RETURN_CHANGED::'
     Return or invoke callback whenever an item is selected (this is the
     default).

'*note FL_RETURN_END::'
     Return or invoke callback on end of an interaction.

'*note FL_RETURN_ALWAYS::'
     Return (or invoke callback) whenever the interaction ends and/or an
     item is selected.

One detail of the interaction that can be adjusted is under which
conditions the nmenu's popup gets closed.  Per default the popup is
closed when an item is selected or (without a selection) when the user
clicks somehwere outside of the popups area.  This can be changed so
that the popup also gets closed (without a selection) when the mouse
button is clicked or released on a non-selectable item (giving the
impression of a "pull-down" menu).  For this purpose there's the
     int fl_set_nmenu_policy(FL_OBJECT *obj, int policy);
function where 'policy' can be one of two values:
'FL_POPUP_NORMAL_SELECT'
     Default, popup stays open until mouse button is released on a
     selectable entry or button is clicked outside the popups area.

'FL_POPUP_DRAG_SELECT'
     Popup is closed when the mouse button is released.
The function returns on success the previous setting of the "policy" and
-1 on error.


File: xforms.info,  Node: Other Nmenu Routines,  Next: Nmenu Attributes,  Prev: Nmenu Interaction,  Up: Nmenu Object

19.2.3 Other Nmenu Routines
---------------------------

To find out which item of a nmenu object was selected last use
     FL_POPUP_RETURN *fl_get_nmenu_item(FL_OBJECT *obj);
The function returns either a pointer to a '*note FL_POPUP_RETURN::'
structure with informations about the selected item (as already
discussed above when talking about callbacks) or 'NULL' if no selection
was made the last time the nmenu object was used.

For some actions, e.g., deletion of an item etc., it is necessary to
know the popup entry that represents it.  Therefore it's possible to
search the list of items according to several criteria:
     FL_POPUP_ENTRY *fl_get_nmenu_item_by_value(FL_OBJECT *obj, long val);
     FL_POPUP_ENTRY *fl_get_nmenu_item_by_label(FL_OBJECT *obj,
                                                const char *label);
     FL_POPUP_ENTRY *fl_get_nmenu_item_by_label(FL_OBJECT *obj,
                                                const char *text);
The first function, '*note fl_get_nmenu_item_by_value()::', searches
through the list of all items (including items in sub-popups) and
returns the first one with the 'val' associated with the item (or 'NULL'
if none is found).  The second, '*note fl_get_nmenu_item_by_label()::'
searches for a certain label as displayed for the item in the popup.
The third, '*note fl_get_nmenu_item_by_text()::' searches for the text
the item was created by (that might be the same as the label text in
simple cases).  Please note that all functions return a structure of
type '*note FL_POPUP_ENTRY::' (and not '*note FL_POPUP_RETURN::', which
gives you direct access to the entry in the popup for the item.

Using e.g., the results of the above searches a nmenu item can be
deleted:
     int fl_delete_nmenu_item(FL_OBJECT *obj, FL_POPUP_ENTRY *item);

Alternatively, an item can be replaced by one or more items:
     FL_POPUP_ENTRY *fl_replace_nmenu_item(FL_OBJECT *obj,
                                           FL_POPUP_ENTRY *old,
                                           const char *new_items, ...);
where 'old' is the item to replace and 'new_items' is a string exactly
as used for '*note fl_add_nmenu_items()::' with informations about the
new item(s).

One also may insert additional items using
     FL_POPUP_ENTRY *fl_insert_nmenu_items(FL_OBJECT *obj,
                                           FL_POPUP_ENTRY *after,
                                           const char *new_items, ...);
where 'after' is the item after which the new items are to be inserted
(use 'NULL' to insert at the very start) and 'new_items' is a string
just like used with '*note fl_add_nmenu_items()::' with informations
about the additional item(s).

As you may remember, there are two different ways to "populate" a nmenu
object.  In one case you pass a kind of format string plus a variable
number of arguments and in the other case an array of '*note
FL_POPUP_ITEM::' structures.  The previously listed functions for
inserting and replacing used the first "interface".  But there are also
three functions for using the alternative interface:
     FL_POPUP_ENTRY *fl_add_nmenu_items2(FL_OBJECT *obj,
                                         FL_POPUP_ITEM *items);
     FL_POPUP_ENTRY *fl_insert_nmenu_items2(FL_OBJECT *obj,
                                            FL_POPUP_ENTRY *after,
                                            FL_POPUP_ITEM *items);
     FL_POPUP_ENTRY *fl_replace_nmenu_items2(FL_OBJECT *obj,
                                             FL_POPUP_ENTRY *old_item,
                                             FL_POPUP_ITEM *items);
All three functions return a pointer to the first new entry in the
nmenu's popup on success and 'NULL' on failure.  The all take a pointer
to the nmenu object as their first argument.

'*note fl_add_nmenu_items2()::' appends the items given by the list
specified via the second argument to the nmenu's popup.  '*note
fl_insert_nmenu_items2()::' inserts one or more new items (as given by
the last argument) after the entry specified by 'after' (if 'after' is
'NULL' the new items are inserted before all existing items).  Finally,
'*note fl_replace_nmenu_items2()::' replaces the existing entry
'old_item' with a new (or a list of new items specified by 'items'.

Finally, there's a function to remove all items from a nmenu object at
once:
     in fl_clear_nmenu(FL_OBJECT *obj);


File: xforms.info,  Node: Nmenu Attributes,  Next: Nmenu Remarks,  Prev: Other Nmenu Routines,  Up: Nmenu Object

19.2.4 Nmenu Attributes
-----------------------

While not "active" the background of the nmenu object is drawn in the
color that can be controlled via the first color argument, 'col1', of
'*note fl_set_object_color()::'.  When "active" (i.e., while the popup
is shown) its background is drawn in the color of second color argument,
'col2', of the same function.  The color of the label when "inactive" is
controlled via '*note fl_set_object_lcolor()::'.  When in "active" state
the color use for the label can be set via the function
     FL_COLOR fl_set_nmenu_hl_text_color(FL_OBJECT *obj, FL_COLOR color);
The function returns the old color on success or '*note FL_MAX_COLORS::'
on failure.  Per default this color is 'FL_BLACK' for nmenus that are
shown as a button while being "active" while for normal nmenus it's the
same color that is used items in the popup when the mouse is hovering
over them.

The size and style of the font used for the label of the nmenu object
can be set via '*note fl_set_object_lsize()::' and '*note
fl_set_object_lstyle()::'.

The rest of the appearance of a nmenu object is given by the appearance
of the popup.  These can be directly set via the functions for setting
the popup appearance as described in *note Popup Attributes::.  To find
out which popup is associated with the nmenu object use the function
     FL_POPUP *fl_get_nmenu_popup(FL_OBJECT *obj);
and then use the popup specific functions to set the appearance.  The
same also holds for the appearance etc. of the items of the popup, a lot
of functions exist that allow to set the attributes of entries of a
popup, *note Popup Attributes::.


File: xforms.info,  Node: Nmenu Remarks,  Prev: Nmenu Attributes,  Up: Nmenu Object

19.2.5 Remarks
--------------

See the demo program 'menu.c'.


File: xforms.info,  Node: Browser Object,  Prev: Nmenu Object,  Up: Part III Choice Objects

19.3 Browser Object
===================

The browser object class is probably the most powerful that currently
exists in the Forms Library.  A browser is a box that contains a number
of lines of text.  If the text does not fit inside the box, a scrollbar
is automatically added so that the user can scroll through it.  A
browser can be used for building up a help facility or to give messages
to the user.

It is possible to create a browser from which the user can select lines.
In this way the user can make its selections from a (possible) long list
of choices.  Both single lines and multiple lines can be selected,
depending on the type of the browser.

* Menu:

* Adding Browser Objects:   Adding Browser Objects
* Browser Types:            Browser Types
* Browser Interaction:      Browser Interaction
* Other Browser Routines:   Other Browser Routines
* Browser Attributes:       Browser Attributes
* Remarks:                  Browser Remarks


File: xforms.info,  Node: Adding Browser Objects,  Next: Browser Types,  Up: Browser Object

19.3.1 Adding Browser Objects
-----------------------------

To add a browser to a form use the routine
     FL_OBJECT *fl_add_browser(int type, FL_Coord x, FL_Coord y,
                               FL_Coord w, FL_Coord h, const char *label);
The meaning of the parameters is as usual.  The label is placed below
the box by default.


File: xforms.info,  Node: Browser Types,  Next: Browser Interaction,  Prev: Adding Browser Objects,  Up: Browser Object

19.3.2 Browser Types
--------------------

The following types of browsers exist (see below for more information
about them):
'FL_NORMAL_BROWSER'
     A browser in which no selections can be made.

'FL_SELECT_BROWSER'
     In this type of browser the user can make single line selections
     which get reset immediately when the mouse button is released.

'FL_HOLD_BROWSER'
     Same as 'FL_SELECT_BROSER' but the selection remains visible till
     the next selection.

'FL_DESELECTABLE_HOLD_BROWSER'
     Same as the 'FL_HOLD_BROWSER' but the user can deselect the
     selected line.

'FL_MULTI_BROWSER'
     Multiple selections can be made and remain visible till
     de-selected.

Hence, the differences only lie in how the selection process works.


File: xforms.info,  Node: Browser Interaction,  Next: Other Browser Routines,  Prev: Browser Types,  Up: Browser Object

19.3.3 Browser Interaction
--------------------------

The user can change the position of the slider or use keyboard cursor
keys (including '<Home>', '<PageDown>', etc.)  to scroll through the
text.  When he/she presses the left mouse below or above the slider, the
browser scrolls one page up or down.  Any other mouse button scrolls one
line at a time (except wheel mouse buttons).  When not using an '*note
FL_NORMAL_BROWSER::' the user can also make selections with the mouse by
pointing to a line or by using the cursor keys.

For '*note FL_SELECT_BROWSER::''s, as long as the user keeps the left
mouse button pressed, the current line under the mouse is highlighted.
Whenever she releases the left mouse button the highlighting disappears
and the browser is returned to the application program.  The application
program can now figure out which line was selected using a call of
'*note fl_get_browser()::' to be described below.  It returns the number
of the last selected line (with the topmost line being line 1).

A '*note FL_HOLD_BROWSER::' works exactly the same except that, when the
left mouse button is released, the selection remains highlighted.  A
'*note FL_DESELECTABLE_HOLD_BROWSER::' additionally allows the user to
undo a selection (by clicking on it again).

An '*note FL_MULTI_BROWSER::' allows the user to select and de-select
multiple lines.  Whenever he selects or de-selects a line the browser
object is returned to the application program (or a callback is executed
when installed) that then can figure out which line was selected using
'*note fl_get_browser()::' (described in more detail below).  That
function returns the number of the last line to be selected or
de-selected.  When a line was de-selected the negation of the line
number gets returned.  I.e., if line 10 was selected the routine returns
10 and if line 10 was de-selected -10.  When the user presses the left
mouse button on a non-selected line and then moves it with the mouse
button still pressed down, he will select all lines he touches with his
mouse until he releases it.  All these lines will become highlighted.
When the user starts pressing the mouse on an already selected line he
de-selects lines rather than selecting them.

Per default a browser only gets returned (or a possibly associated
callback gets invoked) on selection of a line (and, in the case of
'*note FL_MULTI_BROWSER::', on deselections).  This behaviour can be
changed by using the function
     int fl_set_object_return(FL_OBJECT *obj, unsigned int when)
where 'when' can have the following values
'*note FL_RETURN_NONE::'
     Never return or invoke callback.

'*note FL_RETURN_SELECTION::'
     Return or invoke callback on selection of a line.  Please note that
     for '*note FL_MULTI_BROWSER::' the browser may be returned just
     once for a number of lines having been selected.

'*note FL_RETURN_DESELECTION::'
     Return or invoke a callback on deselection of a line.  This only
     happens for '*note FL_DESELECTABLE_HOLD_BROWSER::' and '*note
     FL_MULTI_BROWSER::' objects and, for the latter, the browser may
     get returned (or the callback invoked) just once for a number of
     lines having been deselected.

'*note FL_RETURN_END_CHANGED::'
     Return or invoke callback at end (mouse release) if the text in the
     browser has been scrolled.

'*note FL_RETURN_CHANGED::'
     Return or invoke callback whenever the text in the browser has been
     scrolled.

'*note FL_RETURN_END::'
     Return or invoke callback on end of an interaction for scrolling
     the text in the browser regardless if the text was scrolled or not.

'*note FL_RETURN_ALWAYS::'
     Return or invoke callback on selection, deselection or scrolling of
     text or end of scrolling.

The default setting for 'when' for a browser object is '*note
FL_RETURN_SELECTION::|*note FL_RETURN_DESELECTION::' (unless during the
built of XForms you set the configuration flag '--enable-bwc-bs-hack' in
which case the default is '*note FL_RETURN_NONE::' to keep backward
compatibility with earlier releases of the library).


File: xforms.info,  Node: Other Browser Routines,  Next: Browser Attributes,  Prev: Browser Interaction,  Up: Browser Object

19.3.4 Other Browser Routines
-----------------------------

There are a large number of routines to change the contents of a
browser, select and de-select lines, etc.

To remove all lnes from a browser use
     void fl_clear_browser(FL_OBJECT *obj);

To add a line to a browser use one of
     void fl_add_browser_line(FL_OBJECT *obj, const char *text);
     void fl_add_browser_line_f(FL_OBJECT *obj, const char *fmt, ...);
The first function receives a simple string as the argument, the second
one expects a format string just like for 'printf()' etc.  and followed
by the appropriate number of arguments of the correct types.  The line
to be added may contain embedded newline characters (''\n'').  These
will result in the text being split up into several lines, separated at
the newline characters.

A second way of adding a line to the browser is to use calls of
     void fl_addto_browser(FL_OBJECT *obj, const char *text);
The difference to '*note fl_add_browser_line()::' and '*note
fl_add_browser_line_f()::' is that with these calls the browser will be
shifted such that the newly appended line is visible.  This is useful
when e.g., using the browser to display messages.

Sometimes it may be more convenient to add characters to a browser
without starting of a new line.  To this end, the following routines
exists
     void fl_addto_browser_chars(FL_OBJECT *obj, const char *text);
     void fl_addto_browser_chars_f(FL_OBJECT *obj, const char *fmt, ...);
These functions appends text to the last line in the browser without
advancing the line counter.  The to functions differ in that the first
one takes a simple string argument while the second expects a format
string just as for 'printf()' etc., followed by a corresponding number
of arguments.  Again the text may contain embedded newline characters
(''\n'').  In that case, the text before the first embedded newline is
appended to the last line, and everything afterwards is put onto new
lines.  As in the case of '*note fl_addto_browser()::' the last added
line will be visible in the browser.

You can also insert a line in front of a given line.  All lines after it
will be shifted.  Note that the top line is numbered 1 (not 0).
     void fl_insert_browser_line(FL_OBJECT *obj, int line,
                                 const char *text);
     void fl_insert_browser_line_f(FL_OBJECT *obj, int line,
                                   const char *fmt, ...);
The first function takes a simple string argument while the second one
expects a format string as used for 'printf()' etc.  and the appropriate
number of arguments (of the types specified in the format string).

Please note that on insertion (as well as replacements, see below)
embedded newline characters don't result in the line being split up as
it's done in the previous functions.  Instead they will rather likely
appear as strange looking characters in the text shown.  The only
exception is when inserting into an empty browser or after the last
line, then this function works exactly as if you had called '*note
fl_add_browser_line()::' or '*note fl_add_browser_line_f()::'.

To delete a line (shifting the following lines) use:
     void fl_delete_browser_line(FL_OBJECT *obj, int line);


One can also replace a line using one of
     void fl_replace_browser_line(FL_OBJECT *obj, int line,
                                  const char *text);
     void fl_replace_browser_line_f(FL_OBJECT *obj, int line,
                                    const char *fmt, ...);
The first one takes a simple string for the replacement text while for
the second it is to be specified by a format string exactly as used in
'printf()' etc.  and the appropriate number of arguments of the types
specifed in the format string.  \ As in the case of '*note
fl_insert_browser_line()::' and '*note fl_insert_browser_line_f()::'
newline characters embedded into the replacement text don't have any
special meaning, i.e., they don't result in replacement of more than a
single line.

Making many changes to a visible browser after another, e.g., clearing
it and then adding a number of new lines, is slow because the browser is
redrawn on each and every change.  This can be avoided by using calls of
'*note fl_freeze_form()::' and '*note fl_unfreeze_form()::'.  So a piece
of code that fills in a visible browser should preferably look like the
following
     fl_freeze_form(browser->form);
     fl_clear_browser(browser);
     fl_add_browser_line(browser, "line 1");
     fl_add_browser_line(browser, "line 2");
     ...
     fl_unfreeze_form(brow->form);
where 'browser->form' is the form that contains the browser object named
'browser'.

To obtain the contents of a particular line in the browser, use
     const char *fl_get_browser_line(FL_OBJECT *obj, int line);
It returns a pointer to the text of that line, exactly as it were passed
to the function that created the line.

It is possible to load an entire file into a browser using
     int fl_load_browser(FL_OBJECT *obj, const char *filename);
The routine returns '1' when file could be successfully loaded,
otherwise '0'.  If the file name is an empty string (or the file could
not be opened for reading) the browser is just cleared.  This routine is
particularly useful when using the browser for a help facility.  You can
create different help files and load the needed one depending on
context.

The application program can select or de-select lines in the browser.
To this end the following calls exist with the obvious meaning:
     void fl_select_browser_line(FL_OBJECT *obj, int line);
     void fl_deselect_browser_line(FL_OBJECT *obj, int line);
     void fl_deselect_browser(FL_OBJECT *obj);
The last call de-selects all lines.

To check whether a line is selected, use the routine
     int fl_isselected_browser_line(FL_OBJECT *obj, int line);

The routine
     int fl_get_browser_maxline(FL_OBJECT *obj);
returns the number of lines in the browser.  For example, when the
application program wants to figure out which lines in a '*note
FL_MULTI_BROWSER::' are selected code similar to the following can be
used:
     int total_lines = fl_get_browser_maxline(browser);
     for (i = 1; i <= total_lines; i++)
         if (fl_isselected_browser_line(browser, i))
             /* Handle the selected line */

Sometimes it is useful to know how many lines are visible in the
browser.  To this end, the following call can be used
     int fl_get_browser_screenlines(FL_OBJECT *obj);
Please note that this count only includes lines that are shown
completely in the browser, lines that are partially obscured aren't
counted in.

To obtain the last selection made by the user, e.g., when the browser is
returned, the application program can use the routine
     int fl_get_browser(FL_OBJECT *obj);
It returns the line number of the last selection being made (0 if no
selection was made).  When the last action was a de-selection (only for
'*note FL_MULTI_BROWSER::') the negative of the de-selected line number
is returned.

The following function allows to find out the (unobscured) line that is
currently shown at the top of the browser:
     int fl_get_browser_topline(FL_OBJECT *obj);
Note that the index of the top line is '1', not '0'.  A value of '0' is
returned if the browser doesn't contain any lines.

Finally, the function
shifts the browsers content so that (as far as possible) the line
indexed by 'ln' is shown at the center of the browser.

It is possible to register a callback function that gets called when a
line is double-clicked on.  To do so, the following function is
available:
     void fl_set_browser_dblclick_callback(FL_OBJECT *obj,
                                           void (*cb)(FL_OBJECT *, long),
     `                                     long data);
Of course, double-click callbacks make most sense for '*note
FL_HOLD_BROWSER::'s.

The part if the text visible within the browser can be set
programmatically in a number of ways.  With the functions
     void fl_set_browser_topline(FL_OBJECT *obj, int line);
     void fl_set_browser_bottomline(FL_OBJECT *obj, int line);
the line shown at the top or the bottom can be set (note again that line
numbers start with 1).

Instead of by line number also the amount the text is scrolled in
horizontal and vertical direction can be set with the functions
     void fl_set_browser_xoffset(FL_OBJECT *obj, FL_Coord xoff);
     void fl_set_browser_rel_xoffset(FL_OBJECT *obj, double xval);
     void fl_set_browser_yoffset(FL_OBJECT *obj, FL_Coord yoff);
     void fl_set_browser_rel_yoffset(FL_OBJECT *obj, double yval);
where 'xoff' and 'yoff' indicate how many pixels to scroll horizontally
(relative to the left margin) or vertically (relative to the top of the
text), while 'xval' and 'yval' stand for positions relative to the total
width or height of all of the text and thus have to be numbers between
'0.0' and '1.0'.

There are also a number of functions that can be used to obtain the
current amount of scrolling:
     FL_Coord fl_get_browser_xoffset(FL_OBJECT *obj);
     FL_Coord fl_get_browser_rel_xoffset(FL_OBJECT *obj);
     FL_Coord fl_get_browser_yoffset(FL_OBJECT *obj);
     FL_Coord fl_get_browser_rel_yoffset(FL_OBJECT *obj);

Finally, there's a function that tells you the vertical position of a
line in pixels:
     int fl_get_browser_line_yoffset(FL_OBJECT *obj, imt line);
The return value is just the value that would have to be passed to
'*note fl_set_browser_yoffset()::' to make the line appear at the top of
the browser.  If the line does not exist it returns '-1' instead.


File: xforms.info,  Node: Browser Attributes,  Next: Browser Remarks,  Prev: Other Browser Routines,  Up: Browser Object

19.3.5 Browser Attributes
-------------------------

Never use the boxtype '*note FL_NO_BOX::' for browsers.

The first color argument ('col1') to '*note fl_set_object_color()::'
controls the color of the browser's box, the second ('col2') the color
of the selection.  The text color is the same as the label color,
'obj->lcol'.

To set the font size used inside the browser use
     void fl_set_browser_fontsize(FL_OBJECT *obj, int size);

To set the font style used inside the browser use
     void fl_set_browser_fontstyle(FL_OBJECT *obj, int style);
*Note Label Attributes and Fonts::, for details on font sizes and
styles.

It is possible to change the appearance of individual lines in the
browser.  Whenever a line starts with the symbol ''@'' the next letter
indicates the special characteristics associated with this line.  The
following possibilities exist at the moment:
'f'
     Fixed width font.

'n'
     Normal (Helvetica) font.

't'
     Times-Roman like font.

'b'
     Boldface modifier.

'i'
     Italics modifier.

'l'
     Large (new size is '*note FL_LARGE_SIZE::').

'm'
     Medium (new size is '*note FL_MEDIUM_SIZE::').

's'
     Small (new size is '*note FL_SMALL_SIZE::').

'L'
     Large (new size = current size + 6)

'M'
     Medium (new size = current size + 4)

'S'
     Small (new size = current size - 2).

'c'
     Centered.

'r'
     Right aligned.

'_'
     Draw underlined text.

'-'
     An engraved separator.  Text following ''-'' is ignored.

'C'
     The next number indicates the color index for this line.

'N'
     Non-selectable line (in selectable browsers).

'' ''
     (a space character) Does nothing, can be used to separate between
     the digits specifying a color (following '"@C"', see above) and the
     text of a line starting with a digit.

'@@'
     Regular ''@'' character.

The modifiers (bold and itatic) work by adding '*note FL_BOLD_STYLE::'
and '*note FL_ITALIC_STYLE::' to the current active font index to look
up the font in the font table (you can modify the table using '*note
fl_set_font_name()::' or '*note fl_set_font_name_f()::').

More than one option can be used by putting them next to each other.
For example, '"@C1@l@f@b@cTitle"' will give you the red, large, bold
fixed font, centered word '"Title"'.  As you can see the font change
requests accumulate and the order is important, i.e., '"@f@b@i"' gives
you a fixed bold italic font while '"@b@i@f"' gives you a (plain) fixed
font.

Depending on the font size and style lines may have different heights.

In some cases the character ''@'' might need to be placed at the
beginning of the lines without introducing the special meaning mentioned
above.  In this case you can use '"@@"' or change the special character
to something other than ''@'' using the following routine
     void fl_set_browser_specialkey(FL_OBJECT *obj, int key);

To align different text fields on a line, tab characters (''\t'') can be
embedded in the text.  See '*note fl_set_tabstop()::' on how to set
tabstops.

There are two functions to turn the scrollbars on and off:
     void fl_set_browser_hscrollbar(FL_OBJECT *obj, int how);
     void fl_set_browser_vscrollbar(FL_OBJECT *obj, int how);
'how' can be set to the following values:
'FL_ON'
     Always on.
'FL_OFF'
     Always off.
'FL_AUTO'
     On only when needed (i.e., there are more lines/chars than could be
     shown at once in the browser).
'FL_AUTO' is the default.

Please note that when you switch the scrollbars off the text can't be
scrolled by the user anymore at all (i.e., also not using methods that
don't use scrollbars, e.g., using the cursor keys).

Sometimes, it may be desirable for the application to obtain the
scrollbar positions when they change (e.g., to use the scrollbars of one
browser to control other browsers).  There are two ways to achieve this.
You can use these functions:
     typedef void (*FL_BROWSER_SCROLL_CALLBACK)(FL_OBJECT *, int, void *);
     void fl_set_browser_hscroll_callback(FL_OBJECT *obj,
                                          FL_BROWSER_SCROLL_CALLBACK cb,
                                          void *cb_data);
     void fl_set_browser_vscroll_callback(FL_OBJECT *obj,
                                          FL_BROWSER_SCROLL_CALLBACK cb,
                                          void *cb_data);
After scroll callbacks are set whenever the scrollbar changes position
the callback function is called as
     cb(ob, offset, cb_data);
The first argument to the callback function 'cb' is the browser object,
the second argument is the new xoffset for the horizontal scrollbar or
the new top line for the vertical scrollbar.  The third argument is the
callback data specified as the third argument in the function calls to
install the callback.

To uninstall a scroll callback, use a 'NULL' pointer as the callback
function.

As an alternative you could request that the browser object gets
returned (or a callback invoked) when the the scrollbar positions are
changed.  This can be done e.g., by passing '*note FL_RETURN_CHANGED::'
(if necessary 'OR''ed with flags for also returning on
selection/deselections).  Within the code for dealing with the event you
could check if this is a change event by using the function
     int fl_get_object_return_state(FL_OBJECT *obj);
and test if '*note FL_RETURN_CHANGED::' is set in the return value (by
just logically 'AND''ing both) and then handle the change.

By default, the scrollbar size is based on the relation between the size
of the browser and the size of the text.  To change the default, use the
following routine
     void fl_set_browser_scrollbarsize(FL_OBJECT *obj, int hh, int vw);
where 'hh' is the horizontal scrollbar height and 'vw' is the vertical
scrollbar width.  Use 0 to indicate the default.

The default scrollbar type is 'FL_THIN_SCROLLBAR'.  There are two ways
you can change the default.  One way is to use '*note
fl_set_defaults()::' or '*note fl_set_scrollbar_type()::' to set the
application wide default, another way is to use '*note
fl_get_object_component()::' to get the object handle to the scrollbars
and change the the object type forcibly.  The first method is preferable
because the user can override the setting via resources.  Although the
second method of changing the scrollbar type is not recommended, the
object handle obtained can be useful in changing the scrollbar colors
etc.

Finally there is a routine that can be used to obtain the browser size
in pixels for the text area
     void fl_get_browser_dimension(FL_OBJECT *obj, FL_Coord *x, FL_Coord *y,
                                   FL_COORD *w, FL_COORD *h);
where 'x' and 'y' are measured from the top-left corner of the form (or
the smallest enclosing window).  To establish the relationship between
the text area (a function of scrollbar size, border with and text
margin), you can compare the browser size and text area size.

Finally, the functions
     int fl_get_browser_scrollbar_repeat(FL_OBJECT *obj);
     void fl_set_browser_scrollbar_repeat(FL_OBJECT *obj, int millisec);
allows to determine and control the time delay (in milliseconds) between
jumps of the scrollbar knob when the mouse button is kept pressed down
on the scrollbar outside of the knobs area.  The default value is
100 ms.  The delay for the very first jump is twice that long in order
to avoid jumping to start too soon when only a single click was intended
but the user is a bit slow in releasing the mouse button.


File: xforms.info,  Node: Browser Remarks,  Prev: Browser Attributes,  Up: Browser Object

19.3.6 Remarks
--------------

Since version 1.0.92 there isn't a limit on the maximum length of lines
in a browser anymore.  (The macro 'FL_BROWSER_LINELENGTH' still exists
and is set to 2048 for backward compatibility but has no function
anymore).

See 'fbrowse1.c' for an example program using a '*note
FL_NORMAL_BROWSER::' to view files.  'browserall.c' shows all different
browsers.  'browserop.c' shows the insertion and deletion of lines in a
'*note FL_HOLD_BROWSER::'.

For the browser class, especially multi browsers, interaction via
callbacks is strongly recommended.


File: xforms.info,  Node: Part III Container Objects,  Next: Part III Other Objects,  Prev: Part III Choice Objects,  Up: Top

20 Container Objects
********************

* Menu:

* Folder Object:          Folder Object
* FormBrowser Object:     FormBrowser Object


File: xforms.info,  Node: Folder Object,  Next: FormBrowser Object,  Up: Part III Container Objects

20.1 Folder Object
==================

A tabbed folder is a special container class that is capable of holding
multiple groups of objects (folders) to maximize the utilization of the
screen real estate.  Each folder has its own tab the user can click on
to call up a specific folder from which option can be selected.

                 [image src="xforms_images/folders.png" ]

* Menu:

* Adding Folder Objects:     Adding Folder Objects
* Folder Types:              Folder Types
* Folder Interaction:        Folder Interaction
* Other Folder Routines:     Other Folder Routines
* Remarks:                   Folder Remarks


File: xforms.info,  Node: Adding Folder Objects,  Next: Folder Types,  Up: Folder Object

20.1.1 Adding Folder Objects
----------------------------

To add a tabbed folder to a form use the routine
     FL_OBJECT *fl_add_tabfolder(int type, FL_Coord x, FL_Coord y,
                                 FL_Coord w, FL_Coord h, const char *label);
The geometry indicated by 'x', 'y', 'w', and 'h' is the total area of
the tabbed folders, including the area used for the tab riders.


File: xforms.info,  Node: Folder Types,  Next: Folder Interaction,  Prev: Adding Folder Objects,  Up: Folder Object

20.1.2 Folder Types
-------------------

The following types are available:
'FL_TOP_TABFOLDER'
     Tabs on top of the folders.

'FL_BOTTOM_TABFOLDER'
     Tabs at the bottom of the folders.


File: xforms.info,  Node: Folder Interaction,  Next: Other Folder Routines,  Prev: Folder Types,  Up: Folder Object

20.1.3 Folder Interaction
-------------------------

The folders displayed by the tabbed folder class are simply regular
forms (of type 'FL_FORM'), which in turn contain objects.  Each folder
is associated with a name (shown on the tab rider).  The folder
interacts with the user just like any other form.  Different from other
top-level forms is that only one folder is active at any time.  The user
selects different folders by clicking on the tab rider associated with a
folder.

To set up when the application is notified about events of the tabfolder
or the tabfolders callback is invoked (if installed) use
     void fl_set_object_return(FL_OBJECT *obj, unsigned int when);
where the 'when' argument can be one of
'*note FL_RETURN_NONE::'
     Never report or invoke callback even if the selected folder has
     been changed.

'*note FL_RETURN_CHANGED::'
'*note FL_RETURN_END_CHANGED::'
     Result in a notification when a folder other that the currently
     active one has been selected (this is the default).

'*note FL_RETURN_END::'
'*note FL_RETURN_ALWAYS::'
     Notify when either a new or the already active folder has been
     selected.

In the releases before version 1.0.92 of the library only a callback for
the folder was executed (if one was installed) on change of the selected
folder bur not via e.g., '*note fl_do_forms()::' etc.  This has changed
with version 1.0.92.  To get the old behaviour you have to build XForms
with the '--enable-bwc-bs-hack' being set.

To find out which folder is currently active the following routines the
tab riders are available
     FL_FORM *fl_get_active_folder(FL_OBJECT *obj);
     int fl_get_active_folder_number(FL_OBJECT *obj);
     const char *fl_get_active_folder_name(FL_OBJECT *obj);
All three functions essentially perform the same task, i.e., return a
handle of the active folder, but the kind of handle returned is
different.  The first function returns the form associated with the
folder, the second function the folder sequence number starting from 1
on the left, and the third the folder name.  Depending on the
application setup, one routine might be more convenient than the other
two.

To find out what the previous active folder was (which may be of similar
interest as the currently active one) the following functions can be
used:
     FL_FORM *fl_get_folder(FL_OBJECT *obj)
     int fl_get_folder_number(FL_OBJECT *obj)
     const char *fl_get_folder_name(FL_OBJECT *obj)
Again, depending on the application, one might prefer one routine to the
other two.


File: xforms.info,  Node: Other Folder Routines,  Next: Folder Remarks,  Prev: Folder Interaction,  Up: Folder Object

20.1.4 Other Folder Routines
----------------------------

To populate a tabbed folder, use the following routine
     FL_OBJECT *fl_addto_tabfolder(FL_OBJECT *obj, const char *tab_name,
                                   FL_FORM *folder)
where 'tab_name' is a string (with possible embedded newlines in it)
indicating the text of the tab rider and 'folder' is a regular form
created between calls of '*note fl_bgn_form()::' and '*note
fl_end_form()::'.  Only the pointer to the form is required.  This means
that the application program should not destroy a form that has been
added to a tabbed folder.  The function returns the folder tab object,
which is an object of class 'FL_BUTTON'.  The initial object color,
label color, and other attributes (gravities, for example) of the tab
button are inherited from the tabbed folder object 'obj' and the
location and size of the tab are determined automatically.  You can
change the attributes of the returned object just like any other
objects, but not all possibilities result in a pleasing appearance.
Note that although there is no specific requirement of what the backface
of the folder/form should be, a boxtype other than 'FL_FLAT_BOX' or
'FL_NO_BOX' may not look nice.  If the backface of the form is of
'FL_FLAT_BOX' the associated tab will take on the color of the backface
when activated.

One thing to note is that each tab must have its own form, i.e., you
should not associate the same form with two different tabs.  However,
you can create copies of a form and use these copies.

To access the individual forms on the tabfolder, e.g., in order to
modify something on it, use the following routines
     FL_FORM *fl_get_tabfolder_folder_bynumber(FL_OBJECT *obj, int num);
     FL_FORM *fl_get_tabfolder_folder_byname(FL_OBJECT *obj,
                                             const char *name);
     FL_FORM *fl_get_tabfolder_folder_byname_f(FL_OBJECT *obj,
                                               const char *fnt, ...);
The functions take either the sequence number (the first tab on the left
has a sequence number 1, the second 2 etc) or the tab name, which can
either be passed directly as a string or via a format string like for
'printf()' etc.  and the corresponding (unspecified) arguments.  The
functions return the form associated with the number or the name.  If
the requested number or name is invalid, 'NULL' is returned.

If there are more tabs than that can be shown, the right-most tab will
be shown as "broken".  Clicking on the "broken" tab scrolls the tab to
the right one per each click.  To scroll to the left (if there are tabs
scrolled-off screen from the left), clicking on the first tab scrolls
right.  How many tabs are "hidden" on the left can be determined and
also set using the functions
     int fl_get_tabfolder_offset(FL_OBJECT *ojb);
     int gl_set_tabfolder_offset(FL_OBJECT *obj, int offset);
where 'offset' is the number of tabs hidden on the left.

Although a regular form (top-level) and a form used as a folder behave
almost identically, there are some differences.  In a top-level form,
objects that do not have callbacks bound to them will be returned, when
their states change, to the application program via '*note
fl_do_forms()::' or '*note fl_check_forms()::'.  When a form is used as
a folder, objects that do not have a callback are ignored even when
their states changes.  The reason for this behavior is that presumably
the application does not care while the changes take place and they only
become relevant when the the folder is switched off and at that time the
application program can decide what to do with these objects' states
(apply or ignore for example).  If immediate reaction is desired, just
use callback functions for these objects.

To obtain the number of folders in the tabfolder, the following routine
can be used
     int fl_get_tabfolder_numfolders(FL_OBJECT *obj);

To remove a folder, the following routine is available
     void fl_delete_folder(FL_OBJECT *obj, FL_FORM *folder);
     void fl_delete_folder_bynumber(FL_OBJECT *obj, int num);
     void fl_delete_folder_byname(FL_OBJECT *obj, const char *name);
     void fl_delete_folder_byname_f(FL_OBJECT *obj, const char *fmt, ...);
(the last two function differ in the way the tab names gets passed, the
first is to be called with a simple string while the second expects a
format string as used for 'printf()' etc.  and the appropriate number of
arguments, from which the tab name gets constructed).  wNote that after
deletion, the number of folders in the tabfolder as well as the sequence
numbers are updated.  This means if you want to delete all folders after
the second folder, you can do that by deleting the third folder
repeatedly.

The application program can select which folder to show by using the
following routines
     void fl_set_folder(FL_OBJECT *obj, FL_FORM *folder);
     void fl_set_folder_bynumber(FL_OBJECT *obj, int num);
     void fl_set_folder_byname(FL_OBJECT *obj, const char *name);
     void fl_set_folder_byname_f(FL_OBJECT *obj, const char *fmt, ...);
(The latter two functions only differ in the way the tab name gets
passed top them, the first accepts a simple string while the second
expects a format string as used for 'printf()' etc.  and the appropriate
number of (unspecified arguments, from which the tab name is
constructed.)

Since the area occupied by the tabbed folder contains the space for
tabs, the following routine is available to obtain the actual folder
size
     void fl_get_folder_area(FL_OBJECT *obj, FL_Coord *x, FL_Coord *y,
                             FL_OBJECT *w, FL_OBJECT *h)
where 'x' and 'y' are relative to the (top-level) form the tabbed folder
belongs to.  The size information may be useful for resizing the
individual forms that has to go into the tabbed folder.  Note that the
folder area may not be constant depending on the current tabs (For
example, adding a multi-line tab will reduce the area for the folders).

Since tab size can vary depending on monitor/font resolutions, it is in
general not possible to design the forms (folders) so they fit exactly
into the folder area.  To dynamically adjust the sizes of the folders so
they fit, the following routine is available
     int fl_set_tabfolder_autofit(FL_OBJECT *obj, int how);
where 'how' can be one of the following constants:
'FL_NO'
     Do not scale the form.
'FL_FIT'
     Always scale the form.
'FL_ENLARGE_ONLY'
     Scale the form only if it is smaller than the folder area.
The function returns the old setting.


File: xforms.info,  Node: Folder Remarks,  Prev: Other Folder Routines,  Up: Folder Object

20.1.5 Remarks
--------------

By default, the tab for each folder is drawn with a corner of 3 pixels
so it appears to be a trapezoid rather than a square.  To change the
appearance of the tabs, you can adjust the corner pixels using the
following routine
     int fl_set_default_tabfolder_corner(int n);
where 'n' is the number of corner pixels.  A value of 1 or 0 makes the
tabs appear to be squarish.  The function returns the old value.

A tabbed folder is a composite object consisting of a canvas and several
foldertab buttons.  Each individual form is shown inside the canvas.
Folder switching is accomplished by some internal callbacks bound to the
foldertab button.  Should the application change the callback functions
of the foldertab buttons, these new callback functions must take the
responsibility of switching the active folder.

Some visual effects like colors and label font of the tab rider buttons
can be set all at once by calling the corresponding functions (i.e.,
'*note fl_set_object_color()::', '*note fl_set_object_lstyle()::' etc.)
with the tabbed folder object as the first argument.  Individual tab
rider buttons can also be modified by calling those function with the
corresponding return value of '*note fl_addto_tabfolder()::' as the
first argument.

'fl_free_object(tabfolder)' does not free the individual forms that make
up the tabfolder.

See the demo program 'folder.c' for an example use of tabbed folder
class.

A nested tabfolder might not work correctly at the moment.


File: xforms.info,  Node: FormBrowser Object,  Prev: Folder Object,  Up: Part III Container Objects

20.2 FormBrowser Object
=======================

A form browser is another container class that is capable of holding
multiple forms, the height of which in aggregate may exceed the screen
height.  The form browser also works obviously for a single form that
has a height that is larger than the screen height.

This object class was developed with contributed code from Steve Lamont
of UCSD and the National Center for Microscopy and Imaging Research
(<spl@ucsd.edu>).

* Menu:

* Adding FormBrowser Objects:    Adding FormBrowser Objects
* FormBrowser Types:             FormBrowser Types
* FormBrowser Interaction:       FormBrowser Interaction
* Other FormBrowser Routines:    Other FormBrowser Routines
* Remarks:                       FormBrowser Remarks


File: xforms.info,  Node: Adding FormBrowser Objects,  Next: FormBrowser Types,  Up: FormBrowser Object

20.2.1 Adding FormBrowser Objects
---------------------------------

Adding an object To add a formbrowser object to a form use the routine
     FL_OBJECT *fl_add_formbrowser(int type, FL_Coord x, FL_Coord y,
                                   FL_Coord w, FL_Coord h,
                                   const char *label);
The geometry indicated by 'x', 'y', 'w' and 'h' is the total area of the
formbrowser, including scrollbars.


File: xforms.info,  Node: FormBrowser Types,  Next: FormBrowser Interaction,  Prev: Adding FormBrowser Objects,  Up: FormBrowser Object

20.2.2 FormBrowser Types
------------------------

There's only a single type of formbrowser available, the
'FL_NORMAL_FORMBROWSER'.


File: xforms.info,  Node: FormBrowser Interaction,  Next: Other FormBrowser Routines,  Prev: FormBrowser Types,  Up: FormBrowser Object

20.2.3 FormBrowser Interaction
------------------------------

Once a formbrowser is populated with forms, you can scroll the forms
with the scrollbars and interact with any of the forms.  All objects on
the forms act, for the most part, the same way as they would if they
were on separate forms, i.e., if there are callback functions bound to
the objects, they will be invoked by the main loop when the states of
the objects change.  However, objects on the form that do not have
callbacks bound to them will not be returned by '*note fl_do_forms()::'
or '*note fl_check_forms()::'.

Your application can be notified about changes of the scrollbars of the
formbrowser.  To set up under which conditions the application is
notified or the formbrowsers callback is invoked (if installed) use
     void fl_set_object_return(FL_OBJECT *obj, unsigned int when);
where the 'when' argument can be one of
'*note FL_RETURN_NONE::'
     Never report or invoke callback (this is the default for the
     formbrowser object)

'*note FL_RETURN_CHANGED::'
     Result in a notification whenever the position of one of the
     scrollbars has changed.

'*note FL_RETURN_END_CHANGED::'
     Notification is sent if the position of a scrollbar has changed and
     the mouse button has been released.

'*note FL_RETURN_END::'
     Notification on release of the mouse button.

'*note FL_RETURN_ALWAYS::'
     Notify if the position of a scrollbar has changed or the mouse
     button has been released.


File: xforms.info,  Node: Other FormBrowser Routines,  Next: FormBrowser Remarks,  Prev: FormBrowser Interaction,  Up: FormBrowser Object

20.2.4 Other FormBrowser Routines
---------------------------------

To populate a formbrowser, use the following routine
     int fl_addto_formbrowser(FL_OBJECT *obj, FL_FORM *form);
where 'form' is a pointer to a regular form created between calls of
'*note fl_bgn_form()::' and '*note fl_end_form()::'.  Only the form
pointer is passed to the function, which means that the form should be
valid for the duration of the formbrowser and the application program
should not destroy a form that is added to a formbrowser before deleting
the form from the formbrowser first.  The function returns the total
number of forms in the formbrowser.  Note that although there is no
specific requirement on what the backface of the form should be, not all
boxtypes look nice.

The form so added is appended to the list of forms that are already in
the formbrowser.  You can also use the following routine to obtain the
total number of forms in a formbrowser
     int fl_get_formbrowser_numforms(FL_OBJECT *formbrowser);

Although a regular form (top-level) and a form used inside a formbrowser
behave almost identically, there are some differences.  In a top-level
form, objects that do not have callbacks bound to them will be returned
to the application program when their states change via '*note
fl_do_forms()::' or '*note fl_check_forms()::'.  When a form is used as
member of a formbrowser those objects that do not have callbacks are
ignored even when their states change.

To remove a form from the formbrowser, the following routine is
available
     int fl_delete_formbrowser(FL_OBJECT *obj, FL_FORM *form);
     FL_FORM* fl_delete_formbrowser_bynumber(FL_OBJECT *obj, int num);
In the first function you specify the form to be removed from the
formbrowser by a pointer to the form.  If the form was removed
successfully the function returns the remaining number of forms in the
formbrowser, otherwise -1.

In the second function, you indicate the form to be removed with a
sequence number, an integer between 1 and the number of forms in the
browser.  The sequence number is basically the order in which forms were
added to the formbrowser.  After a form is removed, the sequence numbers
are re-adjusted so they are always consecutive.  The function returns
'NULL' if 'num' was invalid, otherwise it returns address of the form
that was removed.

To replace a form in formbrowser, the following routine is available
     FL_FORM *fl_replace_formbrowser(FL_OBJECT *obj, int num,
                                     FL_FORM *form);
where 'num' is the sequence number of the form that is to be replaced by
'form'.  For example, to replace the first form in the browser with a
different form, you should use 1 for 'num'.  The function returns the
form that has been replaced on success, otherwise 'NULL' is returned.

You can also insert a form into a formbrowser at arbitrary locations
using the following routine
     int fl_insert_formbrowser(FL_OBJECT *obj, int num, FL_FORM *form);
where 'num' is the sequence number before which the new form 'form' is
to be inserted into the formbrowser.  If successful the function returns
the number of forms in the formbrowser, otherwise -1.

To find out the sequence number of a particular form, the following
routine is available
     int fl_find_formbrowser_form_number(FL_OBJECT *obj, FL_FORM *form);
The function returns a number between 1 and the number of forms in the
formbrowser on success, otherwise 0.

To obtain the form handle from the sequence number, use the following
routine
     int fl_get_formbrowser_form(FL_OBJECT *obj, int num);

By default, if the size of the forms exceeds the size of the
formbrowser, scrollbars are added automatically.  You can use the
following routines to control the scrollbars
     void fl_set_formbrowser_hscrollbar(FL_OBJECT *obj, int how);
     void fl_set_formbrowser_vscrollbar(FL_OBJECT *obj, int how);
where 'how' can be one of the following
'FL_ON'
     Always on.
'FL_OFF'
     Always off.
'FL_AUTO'
     On when needed.  This is the default.

The vertical scrollbar by default scrolls a fixed number of pixels.  To
change it so each action of the scrollbar scrolls to the next forms, the
following routine is available
     void fl_set_formbrowser_scroll(FL_OBJECT *obj, int how)
where 'how' can be one of the following
'FL_SMOOTH_SCROLL'
     The default.

'FL_JUMP_SCROLL'
     Scrolls in form increments.

To obtain the form that is currently the first form in the formbrowser
visible to the user, the following can be used
     FL_FORM *fl_get_formbrowser_topform(FL_OBJECT *obj);

You can also set which form to show by setting the top form using the
following routine
     int fl_set_formbrowser_topform(FL_OBJECT *obj, FL_FORM *form);
     FL_FORM* fl_set_formbrowser_topform_bynumber(FL_OBJECT *obj, int num);
The first function returns the sequence number of the form and the
second function returns the form with sequence number 'num'.

Since the area occupied by the formbrowser contains the space for the
scrollbars, the following routine is available to obtain the actual size
of the forms area
     void fl_get_formbrowser_area(FL_OBJECT *obj, int *x, int *y,
                                  int *w, int *h);
where 'x' and 'y' are relative to the (top-level) form the formbrowser
belongs to.

To programatically scroll within a formbrowser in horizontal and
vertical direction, the following routines are available
     int fl_set_formbrowser_xoffset(FL_OBJECT *obj, int offset);
     int fl_set_formbrowser_yoffset(FL_OBJECT *obj, int offset);
where 'offset' is a positive number, measuring in pixels the offset from
the the natural position from the left and the top, respectively.  In
other words, 0 indicates the natural position of the content within the
formbrowser.  An x-offset of 10 means the content is scrolled 10 pixels
to the left.  Similarly an y-offset of 10 means the content is scrolled
by 10 pixels upwards.

To obtain the current offsets, use the following routines
     int fl_get_formbrowser_xoffset(FL_OBJECT *obj);
     int fl_get_formbrowser_yoffset(FL_OBJECT *obj);


File: xforms.info,  Node: FormBrowser Remarks,  Prev: Other FormBrowser Routines,  Up: FormBrowser Object

20.2.5 Remarks
--------------

A call of 'fl_free_object(formbrowser)' does not free the individual
forms, it only frees the formbrowser object itself.

See the demo program 'formbrowser.c' for an example use of formbrowser
class.  A nested formbrowser might not work correctly at the moment.


File: xforms.info,  Node: Part III Other Objects,  Next: Part III Popups,  Prev: Part III Container Objects,  Up: Top

21 Other Objects
****************

* Menu:

* Timer Object:     Timer Object
* XYPlot Object:    XYPlot Object
* Canvas Object:    Canvas Object


File: xforms.info,  Node: Timer Object,  Next: XYPlot Object,  Up: Part III Other Objects

21.1 Timer Object
=================

Timer objects can be used to make a timer that runs down toward 0 or
runs up toward a pre-set value after which it starts blinking and
returns itself to the application program.  This can be used in many
different ways, for example, to give a user a certain amount of time for
completing a task, etc.  Also hidden timer objects can be created.  In
this case the application program can take action at the moment the
timer expires.  For example, you can use this to show a message that
remains visible until the user presses the "OK" button or until a
certain amount of time has passed.

The precision of the timer is not very high.  Don't count on anything
better than, say, 50 milli-seconds, especially when the system is rather
busy.  The timer can trigger early by up to 10 ms.  Run the demo
'timerprec.c' for an actual accuracy measurement.

* Menu:

* Adding Timer Objects:    Adding Timer Objects
* Timer Types:             Timer Types
* Timer Interaction:       Timer Interaction
* Other Timer Routines:    Other Timer Routines
* Timer Attributes:        Timer Attributes
* Remarks:                 Timer Remarks


File: xforms.info,  Node: Adding Timer Objects,  Next: Timer Types,  Up: Timer Object

21.1.1 Adding Timer Objects
---------------------------

To add a timer to a form you use the routine
     FL_OBJECT *fl_add_timer(int type, FL_Coord x, FL_Coord y,
                             FL_Coord w, FL_Coord h, const char *label);
The meaning of the parameters is as usual.


File: xforms.info,  Node: Timer Types,  Next: Timer Interaction,  Prev: Adding Timer Objects,  Up: Timer Object

21.1.2 Timer Types
------------------

There are at the moment three types of timers:
'FL_NORMAL_TIMER'
     Visible, Shows a label in a box which blinks when the timer
     expires.
'FL_VALUE_TIMER'
     Visible, showing the time left or the elapsed time.  Blinks if the
     timer expires.
'FL_HIDDEN_TIMER'
     Not visible.


File: xforms.info,  Node: Timer Interaction,  Next: Other Timer Routines,  Prev: Timer Types,  Up: Timer Object

21.1.3 Timer Interaction
------------------------

When a visible timer expires it starts blinking.  The user can stop the
blinking by pressing the mouse on it or by resetting the timer to 0.

The timer object is returned to the application program or its callback
called when the timer expired per default.  You can also switch off
reporting the expiry of the timer by calling
     int fl_set_object_return(FL_OBJECT *obj, unsigned int when)
with 'when' set to '*note FL_RETURN_NONE::'.  To re-enable reporting
call it with one of '*note FL_RETURN_CHANGED::', '*note
FL_RETURN_END::', '*note FL_RETURN_END_CHANGED::' or '*note
FL_RETURN_ALWAYS::'.


File: xforms.info,  Node: Other Timer Routines,  Next: Timer Attributes,  Prev: Timer Interaction,  Up: Timer Object

21.1.4 Other Timer Routines
---------------------------

To set the timer to a particular value use
     void fl_set_timer(FL_OBJECT *obj, double delay);
'delay' gives the number of seconds the timer should run.  Use 0.0 to
reset/de-blink the timer.

To obtain the time left in the timer use
     double fl_get_timer(FL_OBJECT *obj);

By default, a timer counts down toward zero and the value shown (for
'FL_VALUE_TIMER's) is the time left until the timer expires.  You can
change this default so the timer counts up and shows elapsed time by
calling
     void fl_set_timer_countup(FL_OBJECT *obj, int yes_no);
with a true value for the argument 'yes_no'.

A timer can be temporarily suspended (stopwatch) using the following
routine
     void fl_suspend_timer(FL_OBJECT *obj);
and later be resumed by
     void fl_resume_timer(FL_OBJECT *obj);
Unlike '*note fl_set_timer()::' a suspended timer keeps its internal
state (total delay, time left etc.), so when it is resumed, it starts
from where it was suspended.

Finally there is a routine that allows the application program to change
the way the time is presented in 'FL_VALUE_TIMER':
     typedef char *(FL_TIMER_FILTER)(FL_OBJECT *obj, double secs);
     FL_TIMER_FILTER fl_set_timer_filter(FL_OBJECT *obj,
                                         FL_TIMER_FILTER filter);
The function 'filter' receives the timer ID and the time left for
count-down timers and the elapsed time for up-counting timers (in units
of seconds) and should return a string representation of the time.  The
default filter returns the time in a 'hour:minutes:seconds.fraction'
format.


File: xforms.info,  Node: Timer Attributes,  Next: Timer Remarks,  Prev: Other Timer Routines,  Up: Timer Object

21.1.5 Timer Attributes
-----------------------

Never use 'FL_NO_BOX' as the boxtype for 'FL_VALUE_TIMER's.

The first color argument ('col1') to '*note fl_set_object_color()::'
controls the color of the timer, the second ('col2') is the blinking
color.


File: xforms.info,  Node: Timer Remarks,  Prev: Timer Attributes,  Up: Timer Object

21.1.6 Remarks
--------------

Although having different APIs and the appearance of a different
interaction behaviour, the way timers and timeout callbacks work is
almost identical with one exception: you can deactivate a timer by
deactivating the form it belongs to.  While the form is deactivated, the
timers callback will not be called, even if it expires.  The interaction
will only resume when the form is activated again.

See 'timer.c' for the use of timers.


File: xforms.info,  Node: XYPlot Object,  Next: Canvas Object,  Prev: Timer Object,  Up: Part III Other Objects

21.2 XYPlot Object
==================

A xyplot object gives you an easy way to display a tabulated function
generated on the fly or from an existing data file.  An active xyplot is
also available to model and/or change a function.

* Menu:

* Adding XYPlot Objects:   Adding XYPlot Objects
* XYPlot Types:            XYPlot Types
* XYPlot Interaction:      XYPlot Interaction
* Other XYPlot Routines:   Other XYPlot Routines
* XYPlot Attributes:       XYPlot Attributes
* Remarks:                 XYPlot Remarks


File: xforms.info,  Node: Adding XYPlot Objects,  Next: XYPlot Types,  Up: XYPlot Object

21.2.1 Adding XYPlot Objects
----------------------------

To add an xyplot object to a form use the routine
     FL_OBJECT *fl_add_xyplot(int type, FL_Coord x, FL_Coord y,
                              FL_Coord w, FL_Coord h, const char *label);
It shows an empty box on the screen with the label per default below it.


File: xforms.info,  Node: XYPlot Types,  Next: XYPlot Interaction,  Prev: Adding XYPlot Objects,  Up: XYPlot Object

21.2.2 XYPlot Types
-------------------

The following types are available:
'FL_NORMAL_XYPLOT'
     A solid line is drawn through the data points.
'FL_SQUARE_XYPLOT'
     Data drawn as a solid line plus squares at data points.
'FL_CIRCLE_XYPLOT'
     Data drawn as a solid line plus circles at data points.
'FL_FILL_XYPLOT'
     Data drawn as a solid line with the area under the curve filled.
     Only data points are drawn with.  per default, stars.
'FL_LINEPOINTS_XYPLOT'
     Data drawn as a solid line plus, per default, stars at data point.
'FL_DASHED_XYPLOT'
     Data drawn as a dashed line.
'FL_DOTTED_XYPLOT'
     Data drawn as a dotted line.
'FL_DOTDASHED_XYPLOT'
     Data drawn as a dash-dot-dash line.
'FL_IMPULSE_XYPLOT'
     Data drawn by vertical lines.
'FL_ACTIVE_XYPLOT'
     Data drawn as a solid line plus squares at data points, accepting
     manipulations.
'FL_EMPTY_XYPLOT'
     Only the axes are drawn.

All xyplots per default display the curve auto-scaled to fit the
plotting area.  Although there is no limitation on the actual data, a
non-monotonic increasing (or decreasing) x-axis might be plotted
incorrectly.

XYPlots of type 'FL_POINTS_XYPLOT' and 'FL_LINEPOINTS_XYPLOT' are
special in that the application can change the symbol drawn on the data
point.


File: xforms.info,  Node: XYPlot Interaction,  Next: Other XYPlot Routines,  Prev: XYPlot Types,  Up: XYPlot Object

21.2.3 XYPlot Interaction
-------------------------

Only 'FL_ACTIVE_XYPLOT' report mouse events by default.  Clicking and
dragging the data points (marked with little squares) will change the
data and result in the object getting returned to the application (or
the object's callback getting invoked).  By default, the reporting
happens only when the mouse is released.  In some situations, reporting
changes as soon as they happen might be desirable.  To control when
mouse events are returned use the function
     int fl_set_object_return(FL_OBJECT *obj, unsigned int when);
where 'when' can have the folowing values:
'*note FL_RETURN_NONE::'
     Never return or invoke callback.

'*note FL_RETURN_END_CHANGED::'
     Return or invoke callback at end (mouse release) if one of the
     points has been moved to a different place.  This is the default.

'*note FL_RETURN_CHANGED::'
     Return or invoke callback whenever a point has been moved.

'*note FL_RETURN_END::'
     Return or invoke callback at end (mouse release) regardless if a
     point has been moved is changed or not.

'*note FL_RETURN_ALWAYS::'
     Return or invoke callback when a point has been moved or the mouse
     button has been release).

Please note: an object can also be in inspect mode (see function '*note
fl_set_xyplot_inspect()::' below).  In this case the object gets
returned (or its callback invoked) for all of the above settings except
('*note FL_RETURN_NONE::') when the mouse was released on top of one of
the points.

To obtain the current value of the point that has changed, use the
routine
     void fl_get_xyplot(FL_OBJECT *obj, float *x, float *y, int *i);
where via 'i' the data index (starting from 0) is returned while via 'x'
and 'y' the actual data point gets returned.  If no point has changed
'i' will be set to -1.

It is possible to switch drawing of the squares that mark an active plot
on and off (default is on) using the following routine
     void fl_set_xyplot_mark_active(FL_OBJECT *obj, int yes_no);
with 'yes_no' being set to false (0).

To set or replace the data for an xyplot, use
     void fl_set_xyplot_data(FL_OBJECT *obj, float *x, float *y, int n,
                             const char *title, const char *xlabel,
                             const char *ylabel);
     void fl_set_xyplot_data_double(FL_OBJECT *obj, double *x, double *y, int n,
                                    const char *title, const char *xlabel,
                                    const char *ylabel);
(The 'fl_set_xyplot_data_double()' function allows to pass data of type
'double' but which get "demoted" to 'float' type when assigned to the
xyplot object.)  Here 'x', 'y' is the tabulated function, and 'n' is the
number of data points.  If the xyplot object being set already exists
old data will be cleared.  Note that the tabulated function is copied
internally so you can free or do whatever you want with the 'x' and 'y'
arrays after the function has returned.  'title' is a title that is
drawn above the XYPlot and 'xlabel' and 'ylabel' are the labels drawn at
the x- and y-axes.

You can also load a tabulated function from a file using the routine
     int fl_set_xyplot_file(FL_OBJECT *obj, const char *filename,
                            const char *title, const char *xlabel,
                            const char *ylabel);
The data file should be an ASCII file consisting of data lines.  Each
data line must have two columns, indicating the (x,y) pair with a space,
tab or comma separating the two columns.  Lines that start with any of
'!', ';' or '#' are considered to be comments and are ignored.  The
functions returns the number of data points successfully read or 0 if
the file couldn't be opened.

To get a copy of the current XYPLot data, use
     int fl_get_xyplot_data_size(FL_OBJECT *obj);
     void fl_get_xyplot_data(FL_OBJECT *obj, float *x, *float y, int *n);
The first function returns the number of data points which the second
will return.  The caller must supply the space for the data returned by
'fl_get_xyplot_data()'.  The last argument of that function is again the
number of points that got returned.

All XYPlot objects can be made aware of mouse clicks by using the
following routine
     void fl_set_xyplot_inspect(FL_OBJECT *obj, int yes_no);
Once an XYPlot is in inspect mode, whenever the mouse is released and
the mouse position is on one of the data point, the object is returned
to the caller or its callback is invoked.  You then can use '*note
fl_get_xyplot()::' to find out which point the mouse was clicked on.
Note that for an object of type '*note FL_ACTIVE_XYPLOT::' the data
can't be modified while in inspect mode!

Another, perhaps even more general, way to obtain the values from an
XYPlot is to use a posthandler or an overlay positioner.  See demo
'xyplotall.c' for the use of posthandler and 'positionerXOR.c' for an
example of reading-out xyplot values using an overlayed positioner.


File: xforms.info,  Node: Other XYPlot Routines,  Next: XYPlot Attributes,  Prev: XYPlot Interaction,  Up: XYPlot Object

21.2.4 Other XYPlot Routines
----------------------------

There are several routines to change the appearance of an XYPlot.  First
of all, you can change the number of tic marks using the following
routine
     void fl_set_xyplot_xtics(FL_OBJECT *obj, int major, int minor);
     void fl_set_xyplot_ytics(FL_OBJECT *obj, int major, int minor);
where 'major' and 'minor' are the number of tic marks to be placed on
the axis and the number of divisions between major tic marks.  In
particular, -1 suppresses the tic marks completely while 0 restores the
default settings (which is 5 for the major and 2 for the minor tic
arguments).

Note that the actual scaling routine may choose a value other than that
requested if it decides that this would make the plot look nicer, thus
'major' and 'minor' are only taken as a hint to the scaling routine.
However, in almost all cases the scaling routine will not generate a
major tic that differs from the requested value by more than 3.

Normally the minor tics of logarithmic scales are drawn equidistant.  To
have them also drawn logarithmically use the functions
     int fl_set_xyplot_log_minor_xtics(FL_OBJECT *obj, int yesno);
     int fl_set_xyplot_log_minor_ytics(FL_OBJECT *obj, int yesno);
With this enabled e.g., the minor tics between 1 and 10 (when the
interval is to be divided into 5 subintervals) will be drawn at the
positions 2, 4, 6, and 8 instead of at 10^0.2, 10^0.4, 10^0.6 and
10^0.8.  The functions return the previous setting.

It is possible to label the major tic marks with alphanumerical
characters instead of numerical values.  To this end, use the following
routines
     void fl_set_xyplot_alphaxtics(FL_OBJECT *obj, const char *major,
                                   const char *minor);
     void fl_set_xyplot_alphaytics(FL_OBJECT *obj, const char *major,
                                   const char *minor);
where 'major' is a string specifying the labels with the embedded
character '|' that specifies major divisions.  For example, to label a
plot with Monday, Tuesday etc, 'major' should be given as
'"Monday|Tuesday|..."'.

Parameter 'minor' is currently unused and the minor divisions are set to
1, i.e, no divisions between major tic marks.  Naturally the number of
major/minor divisions set by this routine and '*note
fl_set_xyplot_xtics()::' and '*note fl_set_xyplot_ytics()::' can't be
active at the same time and the one that gets used is the one that was
set last.

The above two functions can also be used to specify non-uniform and
arbitary major divisions.  To achieve this you must embed the major tic
location information in the alphanumerical text.  The location
information is introduced by the '@' symbol and followed by a float or
integer number specifying the coordinates in world coordinates.  The
entire location info should follow the label.  For example,
'"Begin@1|3/4@0.75|1.9@1.9"' will produce three major tic marks at 0.75,
1.0, and 1.9 with labels "3/4", "begin" and "1.9".

To get a gridded XYPlot use the following routines
     void fl_set_xyplot_xgrid(FL_OBJECT *obj, int xgrid);
     void fl_set_xyplot_ygrid(FL_OBJECT *obj, int ygrid);
where 'xgrid' and 'ygrid' can be one of the following
'FL_GRID_NONE'
     No grid.
'FL_GRID_MAJOR'
     Grid for the major divisions only.
'FL_GRID_MINOR'
     Grid for both the major and minor divisions.

The grid line by default is drawn using a dotted line, which you can
change using the routine
     int fl_set_xyplot_grid_linestyle(FL_OBJECT *obj, int style);
where 'style' is the line style ('FL_SOLID', 'FL_DASH' etc.  *Note
Drawing Objects: Part IV Drawing Objects, for a complete list).  The
function returns the old grid linestyle.

By default, the plotting area is automatically adjusted for tic labels
and titles so that a maximum plotting area results.  This can in certain
situations be undesirable.  To control the plotting area manually, the
following routines can be used
     void fl_set_xyplot_fixed_xaxis(FL_OBJECT *obj, const char *lm,
                                    const char *rm)
     void fl_set_xyplot_fixed_yaxis(FL_OBJECT *obj, const char *bm,
                                    const char *tm)
where 'lm' and 'rm' specify the right and left margin, respectively, and
'bm' and 'tm' the bottom and top margins.  The pixel amounts are
computed using the current label font and size.  Note that even for
y-axis margins the length of the string, not the height, is used as the
margin, thus to leave space for one line of text, a single character
(say 'm') or two narrow characters (say 'ii') should be used.

To restore automatic margin computation, set all margins to 'NULL'.

To change the size of the symbols drawn at data points, use the
following routine
     void fl_set_xyplot_symbolsize(FL_OBJECT *obj, int size);
where 'size' should be given in pixels.  The default is 4.

For 'FL_POINTS_XYPLOT' and 'FL_LINEPOINTS_XYPLOT' (main plot or
overlay), the application program can change the symbol using the
following routine
     typedef void (*FL_XYPLOT_SYMBOL)(FL_OBJECT *, int id,
                                      FL_POINT *p, int n, int w, int h);
     FL_XYPLOT_SYMBOL fl_set_xyplot_symbol(FL_OBJECT *obj, int id,
                                           FL_XYPLOT_SYMBOL symbol);
where 'id' is the overlay id (0 means the main plot, and you can use -1
to indicate all), and 'symbol' is a pointer to the function that will be
called to draw the symbols on the data point.  The parameters passed to
this function are the object pointer, the overlay 'id', the center of
the symbol ('p->x', 'p->y'), the number of data points ('n') and the
preferred symbol size ('w', 'h').  If the type of the XYPlot
corresponding to 'id' is not 'FL_POINTS_XYPLOT' or
'FL_LINESPOINTS_XYPLOT', the function will not be called.

To change for example a 'FL_LINEPOINTS_XYPLOT' XYPlot to plot filled
small circles instead of the default crosses, the following code could
be used
     void drawsymbol(FL_OBJECT *obj, int id,
                     FL_POINT *p, int n, int w, int h) {
         int r = (w + h) / 4;
         FL_POINT *ps = p + n;

         for (; p < ps; p++)
             fl_circf(p->x, p->y, r, FL_BLACK);
     }

     ...
     fl_set_xyplot_symbol(xyplot, 0, drawsymbol);
     ...

If a Xlib drawing routine is used it should use the current active
window ('FL_ObjWin(obj)') and the current GC. Take care not to call
routines inside the 'drawsymbol()' function that could trigger a redraw
of the XYPlot (such as '*note fl_set_object_color()::', '*note
fl_set_xyplot_data()::' etc.).

To use absolute bounds (as opposed to the bounds derived from the data),
use the following routines
     void fl_set_xyplot_xbounds(FL_OBJECT *obj, double min, double max);
     void fl_set_xyplot_ybounds(FL_OBJECT *obj, double min, double max);
Data that fall outside of the range set this way will be clipped.  To
restore autoscaling, call the function with 'max' and 'min' set to
exactly the same value.  To reverse the axes (e.g., 'min' at right and
'max' at left), set 'min > max' for that axis.

To get the current bounds, use the following routines
     void fl_get_xyplot_xbounds(FL_OBJECT *obj, float *min, float *max);
     void fl_get_xyplot_ybounds(FL_OBJECT *obj, float *min, float *max);

To replace the value of a particular point use the routine
     void fl_replace_xyplot_point(FL_OBJECT *obj, int index,
                                  double x, double y);
Here 'index' is the index of the value to be replaced.  The first value
has an index of 0.

It is possible to overlay several plots together by calling
     void fl_add_xyplot_overlay(FL_OBJECT *obj, int id, float *x, float *y,
                                int npoints, FL_COLOR col);
where 'id' must be between 1 and 'FL_MAX_XYPLOTOVERLAY' (currently 32).
This limit can be raised (or lowered) by calling the function '*note
fl_set_xyplot_maxoverlays()::'.  Again, the data are copied to an
internal buffer (old data are freed if necessary).

As for the base data, a data file can be used to specify the (x,y)
function
     int fl_add_xyplot_overlay_file(FL_OBJECT *obj, int ID,
                                    const char *file, FL_COLOR col);
The function returns the number of data points successfully read.  The
type ('FL_NORMAL_XYPLOT' etc.)  used in overlay plot is the same as the
object itself.

To change an overlay style, use the following call
     void fl_set_xyplot_overlay_type(FL_OBJECT *obj, int id, int type);
Note that although the API of adding an overlay is similar to adding an
object, an XYPlot overlay is not a separate object.  It is simply a
property of an already existing XYPlot object.

To get the data of an overlay, use the following routine
     void fl_get_xyplot_overlay_data(FL_OBJECT *obj, int id,
                                     float x[], float y[], int *n);
where 'id' specifies the overlay number between 1 and
'FL_MAX_XYPLOTOVERLAY' or the number set via '*note
fl_set_xyplot_maxoverlays()::' (see below).  (Actually, when 'id' is
zero, this function returns the base data).  The caller must supply the
storage space for the data.  Upon function return, 'n' will be set to
the number of data points retrieved.

Sometimes it may be more convenient and efficient to get the pointer to
the data rather than a copy of the data.  To this end, the following
routine is available
     void fl_get_xyplot_data_pointer(FL_OBJECT *obj, int id,
                                     float **x, float **y, int *n);
Upon function return, 'x' and 'y' are set to point to the data storage.
You're free to modify the data and redraw the XYPlot (via '*note
fl_redraw_object()::').  The pointers returned may not be freed.

If needed, the maximum number of overlays an object can have (which by
default is 32) can be changed using the following routine
     int fl_set_xyplot_maxoverlays(FL_OBJECT *obj, int maxoverlays);
The function returns the previous maximum number of overlays.  If the
new number is smaller that what it was before overlays with IDs higher
that the previous number are deleted.

To obtain the number of data points, use the routine
     int fl_get_xyplot_numdata(FL_OBJECT *obj, int id);
where 'id' is the overlay ID (with 0 being the base data set).

To insert a point into an xyplot, use the following routine
     void fl_insert_xyplot_data(FL_OBJECT *obj, int id, int n,
                                double x, double y);
where 'id' is the overlay ID; 'n' is the index of the point after which
the data new point specified by 'x' and 'y' is to be inserted.  Set 'n'
to -1 to insert the point in front.  To append to the data, set 'n' to
be equal or larger than the return value of 'fl_get_xyplot_numdata(obj,
id)'.

To delete an overlay, use the following routine
     void fl_delete_xyplot_overlay(FL_OBJECT *obj, int id);

It is possible to place inset texts on an XYPlot using the following
routine (up to 'FL_MAX_XYPLOTOVERLAY' or the value set via '*note
fl_set_xyplot_maxoverlays()::' of such insets can be accommodated):
     void fl_add_xyplot_text(FL_OBJECT *obj, double x, double y,
                             const char *text, int align, FL_COLOR col);
where 'x' and 'y' are the (world) coordinates where text is to be placed
and align specifies the placement options relative to the specified
point (See '*note fl_set_object_lalign()::' for valid options).  If you
for example specify 'FL_ALIGN_LEFT', the text will appear on the left of
the point and flushed toward the point (see Fig.  21.1).  This is mostly
consistent with the label alignment except that now the bounding box (of
the point) is of zero dimension.  Normal text interpretation applies,
i.e., if text starts with '@' a symbol is drawn.

To remove an inset text, use the following routine
     void fl_delete_xyplot_text(FL_OBJECT *obj, const char *text);

Another kind of inset is the "keys" to the plots.  A key is the
combination of drawing a segment of the plot line style with a piece of
text that describes what the corrsponding line represents.  Obviously,
keys are most useful when you have more than one plot (i.e., overlays).
To add a key to a particular plot, use the following routine
     void fl_set_xyplot_key(FL_OBJECT *obj, int id, const char *keys);
where 'id' again is the overlay ID. To remove a key, set the key to
'NULL'.  All the keys will be drawn together inside a box.  The position
of the keys can be set via
     void fl_set_xyplot_key_position(FL_OBJECT *obj, float x, float y,
                                     int align)
where 'x' and 'y' should be given in world coordinates.  'align'
specifies the alignment of the entire key box relative to the given
position (see Fig.21.1).

The following routine combines the above two functions and may be more
convenient to use
     void fl_set_xyplot_keys(FL_OBJECT *obj, char *keys[],
                              float x, float y, int align);
where 'keys' specifies the keys for each plot.  The last element of the
array must be 'NULL' to indicate the end.  The array index is the plot
id, i.e., 'key[0]' is the key for the base plot, 'key[1]' the key for
the the first overlay etc.

To change the font the key text uses, the following routine is available
     void fl_set_xyplot_key_font(FL_OBJECT *obj, int style, int size);

Data may be interpolated using an nth order Lagrangian polynomial:
     void fl_set_xyplot_interpolate(FL_OBJECT *obj, int id, int degree,
                                    double grid);
where 'id' is the overlay ID (use 0 for the base data set); 'degree' is
the order of the polynomial to use (between 2 and 7) and 'grid' is the
working grid onto which the data are to be interpolated.  To restore the
default linear interpolation, use 'degree' set to 0 or 1.

To change the line thickness of an xyplot (base data or overlay), the
follow routine is available:
     void fl_set_xyplot_linewidth(FL_OBJECT *obj, int id, int width);
Again, use a 'id' of value 0 to indicate the base data.  Setting 'width'
to zero restores the server default and typically is the fastest.

By default, a linear scale in both the x and y direction is used.  To
change the scaling, use the following call
     void fl_set_xyplot_xscale(FL_OBJECT *obj, int scale, double base);
     void fl_set_xyplot_yscale(FL_OBJECT *obj, int scale, double base);
where the valid scaling options for scale are q'FL_LINEAR' and 'FL_LOG',
and 'base' is used only for 'FL_LOG' and in that case is the base of the
logarithm to be used.

Use the following routine to clear an xyplot
     void fl_clear_xyplot(FL_OBJECT *obj);
This routine frees all data associated with an XYPlot, including all
overlays and all inset texts.  This routine does not reset all plotting
options, such as line thickness, major/minor divisions etc. nor does it
free all memories associated with the XYPlot, for this '*note
fl_free_object()::' is needed.

The mapping between the screen coordinates and data can be obtained
using the following routines
     void fl_get_xyplot_xmapping(FL_OBJECT *obj, float *a, float *b);
     void fl_get_xyplot_xmapping(FL_OBJECT *obj, float *a, float *b);
where 'a' and 'b' are the mapping constants and are used as follows:
     screenCoord = a * data + b                 (linear scale)
     screenCoord = a * log(data) / log(p) + b   (log scale)
where 'p' is the base of the requested logarithm.

If you need to do conversions only occasionally (for example, converting
the position of a mouse click to a data point or vice versa) the
following routines might be more convenient
     void fl_xyplot_s2w(FL_OBJECT *obj, double sx, double sy,
                        float *wx, float *wy);
     void fl_xyplot_w2s(FL_OBJECT *obj, double wx, double wy,
                        float *sx, float *sy);
where 'sx' and 'sy' are the screen coordinates and 'wx' and 'wy' are the
world coordinates.

Finally, there's a function for returning the coordinates of the area of
the object used for drawing the data (i.e., the area, when axes are
displayed, which is enclosed by the axes):
     void fl_get_xyplot_screen_area(FL_OBJECT *obj,
                                    FL_COORD *llx, FL_COORD *lly,
                                    FL_COORD *urx, FL_COORD *ury);
     void fl_get_xyplot_world_area(FL_OBJECT *obj,
                                   float *llx, float *lly,
                                   float *urx, float *ury);
where via 'llx' and 'lly' the coordinates of the lower left hand corner
and via 'urx' and 'ury' those of the upper right hand corner are
returned.  The first function returns the corner positions in screen
coordinates (relative to the object), while the secoind returns them in
"world" coordinates.

Per default an XYPlot object only reacts to the left mouse button.  But
sometimes it can be useful to modify this.  To set this call
     void fl_set_xyplot_mouse_buttons(FL_OBJECT *obj,
                                      int mbuttons);
'mbuttons' is the bitwise OR of the numbers 1 for the left mouse button,
2 for the middle and 4 for the right mouse button.

To determine which mouse buttons an XYPlot object reacts to use
     void fl_get_xyplot_mouse_buttons(FL_OBJECT *obj,
                                      unsigned int *mbuttons);
The value returned via 'mbuttons' is the same value as would be used in
'*note fl_set_slider_mouse_buttons()::'.


File: xforms.info,  Node: XYPlot Attributes,  Next: XYPlot Remarks,  Prev: Other XYPlot Routines,  Up: XYPlot Object

21.2.5 XYPlot Attributes
------------------------

Don't use 'FL_NO_BOX' as the boxtype of an XYPlot object that is to be
changed dynamically.  To change the font size and style for the tic
labels, inset text etc., use '*note fl_set_object_lsize()::' and '*note
fl_set_object_lstyle()::'.

The first color argument ('col1') to '*note fl_set_object_color()::'
controls the color of the box and the second ('col2') the actual XYPlot
color.


File: xforms.info,  Node: XYPlot Remarks,  Prev: XYPlot Attributes,  Up: XYPlot Object

21.2.6 Remarks
--------------

The interpolation routine is public and can be used in the application
program
     int fl_interpolate(const float *inx, const float *iny, int num_in,
                        float *outx, float *outy, double grid, int ndeg);
If successful, the function returns the number of points in the
interpolated function ('(inx[num_in - 1] - inx[0]) / grid + 1.01'),
otherwise it returns -1.  Upon return, 'outx' and 'outy' are set to the
interpolated values.  The caller must allocate the storage for 'outx'
and 'outy'.

See 'xyplotall.c' and 'xyplotactive.c' for examples of the use of XYPlot
objects.  There is also an example program called 'xyplotover.c', which
shows the use of overlays.  In addition, 'xyplotall.c' shows a way of
getting all mouse clicks without necessarily using an active XYPlot.

It is possible to generate a PostScript output of an XYPlot.  See the
function '*note fl_object_ps_dump()::' documented in Part V.


File: xforms.info,  Node: Canvas Object,  Prev: XYPlot Object,  Up: Part III Other Objects

21.3 Canvas Object
==================

A canvas is a managed plain X (sub)window.  It it different from the
free object in that a canvas is guaranteed to be associated with a
window that is not shared with any other object, thus an application
program has more freedom in utilizing a canvas, such as using its own
colormap or rendering double-buffered OpenGL in it etc.  A canvas is
also different from a raw application window because a canvas is
decorated differently and its geometry is managed, e.g., you can use
'*note fl_set_object_resize()::' to control its position and size after
its parent form is resized.

You also should be aware that when using a canvas you'll probably mostly
program directly using basic Xlib functions, XForms doesn't supply much
more than a few helper functions.  You'll rather likely draw to it with
Xlib functions and will be dealing with 'XEvent's yourself (instead
having them taken care of by XForms and cenverted to some simpler to use
events that then just return the object from '*note fl_do_forms()::' or
invoke an associated callback function.  Thus you will typically need a
basic knowledge of how to program via the X11 Xlib.

* Menu:

* Adding Canvas Objects:     Adding Canvas Objects
* Canvas Types:              Canvas Types
* Canvas Interaction:        Canvas Interaction
* Other Canvas Routines:     Other Canvas Routines
* Canvas Attributes:         Canvas Attributes
* OpenGL Canvas:             OpenGL Canvas


File: xforms.info,  Node: Adding Canvas Objects,  Next: Canvas Types,  Up: Canvas Object

21.3.1 Adding Canvas Objects
----------------------------

Adding an object To add a canvas to a form you use the routine
     FL_OBJECT *fl_add_canvas(int type, FL_Coord x, FL_Coord y,
                              FL_Coord w, FL_Coord h, const char *label);
The meaning of the parameters is as usual.  The label is not drawn but
used as the window name for possible resource and playback purposes.  If
label is empty, the window name will be generated on the fly as
'flcanvasn', where 'n = 0, 1,...'.


File: xforms.info,  Node: Canvas Types,  Next: Canvas Interaction,  Prev: Adding Canvas Objects,  Up: Canvas Object

21.3.2 Canvas Types
-------------------

The only types of canvases currently available is 'FL_NORMAL_CANVAS'.


File: xforms.info,  Node: Canvas Interaction,  Next: Other Canvas Routines,  Prev: Canvas Types,  Up: Canvas Object

21.3.3 Canvas Interaction
-------------------------

The canvas class is designed to maximize the programmer's ability to
deal with situations where standard form classes may not be flexible
enough.  With canvases, the programmer has complete control over
everything that can happen to a window.  It thus doesn't work like other
objects that get returned by '*note fl_do_forms()::' etc. or have their
callbacks invoked.

Instead the user can request that for specific 'X' events (not XForms
object events like 'FL_PRESS', 'FL_KEYPRESS' etc.!)  callbacks are
invoked that receive all information about the 'XEvent' that led to
their invocation.  This obviously requires some understanding of how the
X Window system works.

The interaction with a canvas is typically set up as follows.  First,
you register the 'X' events you're interested in and their handlers
using the following routine
     typedef int (*FL_HANDLE_CANVAS)(FL_OBJECT *obj, Window win,
                                     int win_width, int win_height,
                                     XEvent *xev, void *user_data);
     void fl_add_canvas_handler(FL_OBJECT *obj, int event,
                                FL_HANDLE_CANVAS handler, void *user_data);
where 'event' is the 'XEvent' type, e.g., 'Expose' etc.  The '*note
fl_add_canvas_handler()::' function first registers a procedure with the
event dispatching system of the Forms Library, then it figures out the
event masks corresponding to the event 'event' and invokes '*note
fl_addto_selected_xevent()::' to solicit the event from the server.
Other book keeping (e.g., drawing the box that encloses the canvas,
etc.)  is done by the object handler.

When a canvas handler is installed the library tries to set the correct
mask for the the 'XEvent' (which then tells the X Window system which
events to pass on to the Forms Library).  But since translation from an
'XEvent' to an 'XEvent' mask is not unique, the default translation of
the 'XEvent' to a mask may or may not match exactly the intention of the
application.  Two events, namely 'MotionNotify' and 'ButtonPress', are
likely candidates that need further clarification from the application.
There are two functions to add or delete from the mask, '*note
fl_addto_selected_xevent()::' and '*note fl_remove_selected_xevent()::'.

By default, when a mouse motion handler (i.e., for the 'MotionNotify'
events) is registered, it is assumed that, while the application wants
to be informed about mouse movements, it's not interested in a continous
motion monitoring (tracking), thus per default 'MotionNotify' events are
requested with 'PointerMotionHintMask' being set in the mask to reduce
the number of events generated.  If this is not the case and in fact the
application wants to use the mouse motion as some type of graphics
control, the default behavior would appear "jerky" as not every mouse
motion is reported.  To change the default behavior so that every mouse
motion is reported, you need to call '*note
fl_remove_selected_xevent()::' with mask set to 'PointerMotionHintMask'.
Furthermore, the mouse motion is reported regardless if a mouse button
is pressed or not.  If the application is interested in mouse motion
only when a mouse button is pressed '*note
fl_remove_selected_xevent()::' should be called with a mask of
'PointerMotionMask|PointerMotionHintMask'.

With 'ButtonPress' events you need to call '*note
fl_addto_selected_xevent()::' with a mask of 'OwnerGrabButtonMask' if
you are to add or remove other canvas handlers in the button press
handler.

To remove a registered handler, use
     void fl_remove_canvas_handler(FL_OBJECT *obj, int event,
                                   FL_CANVAS_HANDLER handler);
After this function call the canvas ceases to receive the events for
'event'.  The corresponding default bits in the 'XEvent' mask as were
set by '*note fl_add_canvas_handler()::' are cleared.  If you added
extra ones with '*note fl_addto_selected_xevent()::' you should reset
them using '*note fl_remove_selected_xevent()::'.

To obtain the window ID of a canvas, use
     Window fl_get_canvas_id(FL_OBJECT *obj);
or use the generic function (macro) (recommended)
     Window FL_ObjWin(FL_OBJECT *obj);

Of course, the window ID only has a meaning after the form/canvas is
shown.  When the canvas or the form the canvas is on is hidden (via
'*note fl_hide_object()::' or '*note fl_hide_form()::'), the canvas
window may be destroyed.  If the canvas is shown again, a new window ID
for the canvas may be created.  Thus recording the canvas window ID in a
static variable is not the right thing to do.  It is much safer (and it
doesn't add any run-time overhead) to obtain the canvas window ID via
'*note FL_ObjWin()::' whenever it's needed.  If your application must
show and hide the canvas/form repeatedly, you might consider to "unmap"
the window, a way of removing the window from the screen without
actually destroying it and later re-mapping the window to show it.  The
Xlib API functions for doing this are 'XUnmapWindow()' and
'XMapWindow()'.  Both require two arguments.  the display, which you can
determine by calling '*note fl_get_display()::' and the window ID, which
can be obtained by using 'form->window' if you want to (un)map a form or
'FL_ObjWin(obj)' for a canvas.


File: xforms.info,  Node: Other Canvas Routines,  Next: Canvas Attributes,  Prev: Canvas Interaction,  Up: Canvas Object

21.3.4 Other Canvas Routines
----------------------------

Upon canvas creation, all its window related attributes, e.g., visual,
depth and colormap etc., are inherited from its parent (i.e., the window
of the form the canvas belongs to).  To modify any attributes of the
canvas, use the following routine
     void fl_set_canvas_attributes(FL_OBJECT *obj, unsigned mask,
                                   XSetWindowAttributes *xswa);
See 'XSetWindowAttributes()' for the definition of the structure
members.  Note that this routine should not be used to manipulate
events.

Other functions exists that can be used to modify the color/visual
property of a canvas:
     void fl_set_canvas_colormap(FL_OBJECT *obj, Colormap map);
     Colormap fl_get_canvas_colormap(FL_OBJECT *obj);
     void fl_set_canvas_visual(FL_OBJECT *obj, Visual *vi);
     void fl_set_canvas_depth(FL_OBJECT *obj, int depth);
     int fl_get_canvas_depth(FL_OBJECT *obj);
Note that changing visual or depth does not generally make sense once
the canvas window is created (which happens when the parent form is
shown).  Also, typically if you change the canvas visual, you probably
should also change the canvas depth to match the visual.

Caution should also applied when using '*note
fl_set_canvas_colormap()::': when the canvas window goes away, e.g., as
a result of a call of '*note fl_hide_form()::', the colormap associated
with the canvas is freed (destroyed).  This likely will cause problems
if a single colormap is used for multiple canvases as each canvas will
attempt to free the same colormap, resulting in an X error.  If your
application works this way, i.e., the same colormap is used on multiple
canvases (via '*note fl_set_canvas_colormap()::'), you should use the
following routine to prevent the canvas from freeing the colormap:
     void fl_share_canvas_colormap(FL_OBJECT *obj, Colormap colormap);
This function works the same way as '*note fl_set_canvas_colormap()::'
except that it also sets a internal flag so the colormap isn't freed
when the canvas goes away.

By default, canvases are decorated with an 'FL_DOWN_FRAME'.  To change
the decoration, change the the boxtype of the canvas and the boxtype
will be translated into a frame that best approximates the appearance of
the request boxtype (e.g., a 'FL_DOWN_BOX' is translated into a
'FL_DOWN_FRAME' etc).  Note that not all frame types are appropriate for
decorations.

The following routine is provided to facilitate the creation of a
colormap appropriate for a given visual to be used with a canvas:
     Colormap fl_create_colormap(XVisualInfo *xvinfo, int n_colors);
where 'n_colors' indicates how many colors in the newly created colormap
should be filled with XForms' default colors (to avoid flashing
effects).  Note however, that the colormap entry 0 is allocated with
either black or white even if you specify 0 for 'n_colors'.  To prevent
this from happening (so you get a completely empty colormap), set
'n_colors' to -1.  *Note Drawing Objects: Part IV Drawing Objects, on
how to obtain the 'XVisualInfo' for the window.  Depending on the window
manager, a colormap other than the default may not get installed
correctly.  If you're working with such a window manager, you may have
to install the colormap yourself when the mouse pointer enters the
canvas using 'XInstallColormap()'.

By default, objects with shortcuts appearing on the same form as the
canvas will "steal" keyboard inputs if they match the shortcuts.  To
disable this feature, use the following routine with a false (0) value
for 'yes_no':
     void fl_canvas_yield_to_shortcut(FL_OBJECT *obj, int yes_no);

To clear the canvas use
     void fl_clear_canvas(FL_OBJECT *obj);
If '*note fl_set_object_color()::' gas been called on the object the
first color passed to the function will be used to draw the background
of the color, otherwise it's drawn in black.


File: xforms.info,  Node: Canvas Attributes,  Next: OpenGL Canvas,  Prev: Other Canvas Routines,  Up: Canvas Object

21.3.5 Canvas Attributes
------------------------

Some of the attributes, such as boxtype, do not apply to the canvas
class.

The first color argument ('col1') to '*note fl_set_object_color()::' can
be used to set the background color of the canvas (by default, a canvas
has no background color).  The second argument ('col2') controls the
decoration color (if applicable).


File: xforms.info,  Node: OpenGL Canvas,  Prev: Canvas Attributes,  Up: Canvas Object

21.3.6 OpenGL Canvas
--------------------

Deriving specialized canvases from the general canvas object is
possible.  See the next subsection for general approaches how this is
done.  The following routines work for OpenGL (under X) as well as Mesa,
a free OpenGL clone.

To add an OpenGL canvas to a form, use the following routine
     FL_OBJECT *fl_add_glcanvas(int type, FL_Coord x, FL_Coord y,
                                FL_Coord w, FL_Coord h, const char *label);
where 'type' is the same as for a normal canvas.  A "glcanvas" created
this way will have the following attributes by default
     GLX_RGBA,
     GLX_DEPTH_SIZE: 1,
     GLX_RED_SIZE: 1, GLX_GREEN_SIZE: 1, GLX_BLUE_SIZE: 1,
     GLX_DOUBLEBUFFER

The application program can modify these defaults using the following
routine (before the creation of glcanvases)
     void fl_set_glcanvas_defaults(const int *attributes);
See 'glXChooseVisual()' for a list of valid attributes.

To get the current defaults use
     void fl_get_glcanvas_defaults(int *attributes);

It is also possible to change the attributes on a canvas by canvas basis
by utilizing the following routine:
     void fl_set_glcanvas_attributes(FL_OBJECT *obj, const int *attributes);
Note that this routine can be used to change a glcanvas attributes on
the fly even if the canvas is already visible and active.

To obtain the attributes of a particular canvas, use the following
routine
     void fl_get_glcanvas_attributes(FL_OBJECT *obj, int attributes[]);
The caller must supply the space for the attribute values.

To obtain the the glx context (for whatever purposes), use
     GLXContext fl_get_glcanvas_context(FL_OBJECT *obj);

Note that by default the rendering context created by a glcanvas uses
direct rendering (i.e., by-passing the Xserver).  To change this
default, i.e., to always render through the Xserver, use the following
routine:
     void fl_set_glcanvas_direct(FL_OBJECT *obj, int yes_no);
with the argument 'yes_no' set to false (0).

Remember that OpenGL drawing routines always draw into the window the
current context is bound to.  For application with a single canvas, this
is not a problem.  In case of multiple canvases, the canvas driver takes
care of setting the proper context before invoking the expose handler.
In some cases, the application may want to draw into canvases actively.
In this case, explicit drawing context switching may be required.  To
this end, use the following routine
     void fl_activate_glcanvas(FL_OBJECT *obj);
before drawing into glcanvas object.

Finally there is a routine that can be used to obtain the 'XVisual'
information that is used to create the context
     XVisualInfo *fl_get_glcanvas_xvisualinfo(FL_OBJECT *obj);
See demo program 'gl.c' for an example use of a glcanvas.


File: xforms.info,  Node: Part III Popups,  Next: Part III Deprecated Objects,  Prev: Part III Other Objects,  Up: Top

22 Popups
*********

Popup is not an object class.  In contrast to normal objects popups are
only shown for a short time in their own window and, while they are
shown, no interaction with other objects is possible.  So they don't fit
directly into the normal event loop where one waits for user actions via
'*note fl_do_forms()::'.  Instead, when used stand-alone (e.g., for a
context menu) they are shown on a call of the function '*note
fl_popup_do()::', which returns when the the user is done with the popup
and it has been removed from the screen.  Only idle callbacks and timers
etc. are executed in the background while a popup is being shown.

Popups are the building blocks for menu and selector objects, which
internally create and use popups.  Thus it might be helpful to
understand how popups work to get the most out of these objects.

All functions dealing with popups have names starting with
''fl_popup_'', functions for individual entries start with
''fl_popup_entry_'' and typedefs as well as macros with ''FL_POPUP_''.

* Menu:

* Adding Popups:          Adding Popups
* Popup Interaction:      Popup Interaction
* Other Popup Routines:   Other Popup Routines
* Popup Attributes:       Popup Attributes


File: xforms.info,  Node: Adding Popups,  Next: Popup Interaction,  Up: Part III Popups

22.1 Adding Popups
==================

There are two ways to create and populate a popup with entries.  The
first method, that allows more fine-grained control consists of first
generating a popup and then adding entries.  Using this method all the
properties of entries can be set immediately.  The second method, to be
discussed later, is simpler and may be sufficient for many applications,
and internally uses the first method.

To define a new popup using the more general interface call
     FL_POPUP *fl_popup_add(Window win, const char *title);
The function returns the address of the new popup on success and 'NULL'
on failure.  'win' is the window of a parent object (use '*note
FL_ObjWin()::' to find out about it).  You can also use '*note
fl_root::' for the root window, with 'None' having the same effect .
'title' is an optional string that gets shown at the top of the popup in
a framed box.  If not wanted pass an empty string or 'NULL'.  The
function returns a pointer to a new popup or 'NULL' on failure.

The title may contain embedded newline characters, this allows to create
titles that span more than one line.)

There is no built-in limit to the number of popups that can be created.

Once you have popup you may add one or more entries by using
     FL_POPUP_ENTRY *fl_popup_add_entries(FL_POPUP *popup,
                                          const char *entries, ...);
On success the return value is the address of the first entry created
and 'NULL' on failure.  The first argument, 'entries', is a pointer to
the popup the new entry (or entries) is added to.  The second argument,
'entries', encodes information about the entries to add.  In the most
simple case it consists just of the entries texts, separated by '|'
characters, e.g., '"Item 1|Item 2|Item 3"'.  This would create three
simple entries in the popup with labels '"Item 1"', '"Item 2"' and
'"Item 3"'.

The 'entries' string may contain newline characters which allows to
create entries that span more than a single line.

There's no built-in limit to the number of entries than be added to a
popup.  '*note fl_popup_add_entries()::' can be called repeatedly to
append further entries to a popup.

It often is necessary to have more complex entries.  E.g., one may want
to have keyboard shortcuts for entries, which are shown on the right
hand side of an entry, one may want to have sub-popups or set callbacks
etc.  This can be achieved by embedding special character sequences
within the string describing the entries and passing further arguments
to the function, similar to the use of a format string in e.g.,
'printf(3)'.  All special sequences start with a '%'.

The following sequences are recognized:
'%x'
     Set a value of type 'long int' that's passed to all callback
     routines for the entry.  The value must be given in the arguments
     following the 'entries' string.

'%u'
     Set a 'user_void' pointer that's passed to all callbacks of the
     entry.  The pointer must be specified in the arguments following
     the 'entries' string.

'%f'
     Set a callback function that gets called when the entry is
     selected.  The function is of type
          int callback(FL_POPUP_RETURN *r);
     Information about the entry etc. gets passed to the callback
     function via the 'FL_POPUP_RETURN' structure (see below) and the
     return value of the function can be used to keep the selection
     being reported back to the caller of '*note fl_popup_do()::' by
     returning a value of 'FL_IGNORE' (-1).  The functions address must
     be given in the arguments following the 'entries' string.

'%E'
     Set a callback routine that gets called each time the mouse enters
     the entry (as long as the entry isn't disabled or hidden).  The
     type of the function is the same as that of the callback function
     for the selection of the item but it's return value is never used.
     The functions address must be given in the arguments following the
     'entries' string.

'%L'
     Set a callback routine that gets called each time the mouse leaves
     the entry.  The type of the function is the same as that of the
     callback function for the selection of the entry but it's return
     value is never used.  The functions address must be given in the
     arguments following the 'entries' string.

'%m'
     When this is specified a sub-popup gets opened when the mouse
     enters the entry (the entry itself thus can't be selected).  The
     sub-popup to be opened must be an already existing popup and its
     address must be given in the arguments following the 'entries'
     string.  A triangle will be drawn on the right of the entry to
     indicate that it's an entry for a sub-popup.

     Mutually exclusive with '%t', '%T', '%r', '%R' and '%l'.

'%t'
'%T'
     This makes the entry a "toggle" entry, an entry that represents
     binary states and gets a check-mark drawn on its left if in "on"
     state.  If created with '%t' its in "off" state at the start, if
     created with '"T"' its in "on" state.  Switching states happens
     automatically when the entry is selected.

     Mutually exclusive with '%m', '%r', '%R' and '%l'.

'%r'
'%R'
     This makes the entry a "radio" entry, i.e., it becomes part of a
     group of entries of which only one can be "on" at a time.  The
     group, an integer value (don't use 'INT_MIN' and 'INT_MIN'), must
     be given in the arguments following the 'entries' string.

     Radio entries are drawn with a small circle to the left, with the
     one for the entry in "on" state filled with a color (blue per
     default).  When a radio entry is selected by the user that was in
     "off" state the entry of the group that was is "on" state before is
     automatically switched to "off" state.

     If the entry gets created with '%r' the entry is in "off" state, if
     created with '%R' it's in "on" state (in that case all entries
     created before in "on" state are reset to "off" state, i.e., the
     one created last "wins").

     Mutually exclusive with '%m', '%t', '%T' and '%l'.

'%l'
     This creates not a real entry but indicates that a line is to be
     drawn to visually group other entries.  While other properties can
     be set for such an "entry" only the "hidden" property (see below)
     is taken into acount.

     Mutually exclusive with '%m', '%t', '%T', '%' and '%R'.

'%d'
     Marks the entry as disabled, i.e., it can't be selected and its
     text is per default drawn in a different color
'%h'
     Marks the entry as hidden, i.e., it is not shown while in this
     state.

'%S'
     For entries with shortcut keys it's quite common to have them shown
     on the right hand side.  Using '%S' you can split the entrys text
     into two parts, the first one (before '%S') being drawn flushed
     left and the second part flushed right.  Note that using this
     special sequence doesn't automatically sets a shortcut key, this
     still has to be done using '%s'.

'%s'
     Sets one or more shortcut keys for an entry.  Requires a string
     with the shortcuts in the arguments following the 'entries' string,
     *note Shortcuts:: for details on how to define shortcuts.  Please
     note that the character in the label identical to the shortcut
     character is only shown as underlined if '%S' isn't used.

'%%'
     Use this to put a '%' character within the text of an entry.

Please note that since '*note fl_popup_add_entries()::' is a variadic
function (i.e., it takes a variable number of arguments) only very
limited error checking is possible and thus it is of importance that the
arguments passed to the function have exactly the required types!

The return value of '*note fl_popup_add_entries()::' is a pointer to the
first of the entries created.  Since entries are stored as a linked list
this value can be used to iterate over the list (see below for more
information about the '*note FL_POPUP_ENTRY::' structure).  If the
function returns 'NULL' no entries were created.

A typical piece of code creating a popup may look like this:
     int save_cb(FL_POPUP_RETURN *result) {
         ...
     }

     int main(int argc, char *argv[]) {
        FL_POPUP *popup;
        File *fp;

        ...

        popup = fl_popup_add(None, NULL);
        fl_popup_add_entries(popup,
                             "Save%SCtrl+S%s%f%u|"
                             "Quit%SEsc%s|"
                             "%l|"
                             "Work Offline%SCtrl+O%T%s",
                             "^S", save_cb, (void *) fp,
                             "^[",
                             "^O");
         ...
     }
This creates a popup with three entries.  The first one has the label
'"Save"' shown at the left and '"Ctrl+S"' at the right can be selected
by pressing '<Ctrl>S', in which case the function 'save_cb()' will be
invoked with a pointer to a structure that, beside other informations,
contains the file pointer 'fp'.  The second entry has the labels
'"Quit"' and '"Esc"' and it's shortcut key is set to '<Esc>'.  Below
this entry a separator line is drawn, followed by the third entry with
labels '"Work Offline"' and '"Ctrl+O"' and shortcut key '<Ctrl>O'.  This
label is a "toggle" entry in "on" state, thus a check-marker is shown
beside it.

A few remarks about the callback routines.  All have a type of
'FL_POPUP_CB' as given by this 'typedef':
     typedef int (*FL_POPUP_CB)(FL_POPUP_RETURN *);
There are three kinds of callbacks, all with the same type.  Whenever an
item is entered (by moving the mouse on top of it or with the keyboard)
its enter callback function is invoked (if one is set).  Exceptions are
entries that are disabled or hidden or entries, that just stand for
separator lines.  When an entry that can receive enter callbacks is
left, its leave callback is invoked.

Leave callbacks are not called when a selection has been made.  Instead,
only the selection callback for the selected entry is invoked.

A "sub-popup entry", i.e., an entry that when entered results in a
sub-popup to open, also can have an enter callback.  Its leave callback
is not called when the user moves the mouse onto the sub-popup but only
once the sub-popup has been closed again and the mouse has been moved
off the sub-popup entry.

While enter and leave callback functions are defined to return an
integer value, it's never used.  But for the third kind of callback,
invoked on selection of an entry, this isn't true.  Instead, the
callbacks return value is important: if it is 'FL_IGNORE' (-1), the
selection isn't reported back to the caller (and following callbacks
also aren't called).  This can be useful when the callback function
already does everything required and nothing is left to be done.

All callbacks receive a pointer to a structure of the type
'FL_POPUP_RETURN':
     typedef struct {
         long int              val;       /* value assigned to entry */
         void                 *user_data; /* pointer to user data */
         const char           *text;      /* text of selected popup entry */
         const char           *label;     /* text drawn on left */
         const char           *accel;     /* text drawn on right */
         const FL_POPUP_ENTRY *entry;     /* selected popup entry */
         const FL_POPUP       *popup;     /* (sub-) popup it belongs to */
     } FL_POPUP_RETURN;

'val' is the value set by '"%x"'.  If '"%x"' wasn't given, it's an
automatically generated value: when a popup is created with '*note
fl_popup_add_entries()::' a counter is initalized to 0.  Whenever an
entry gets added the value of the counter is assigned to the entry and
then incremented.  Unless a different value is set explicitely via
'"%x"' the first entry added to a popup thus gets a value 'val' of 0,
the second one gets 1 etc.  This even holds for entries that just stand
for separator lines.  In simple situations the value of 'val' is
probably sufficient to identify which entry got selected.

Please note: it is possible that by setting the 'val' members two or
more structures for items of the same popup get the same value.  It is
the programmers responsibility to avoid that (unless, of course, that's
just what you intended).

The 'user_data' member of the structure is the 'user_void' pointer set
via '"%u"'.  It allows to pass more complex data to the callback
function (or have returned on selection of an entry.

The 'text' member is exactly the string used to create the entry,
including all the special sequences starting with ''%''.  'label' is
what's left after all those sequences as well as backspace characters
have been removed, tabs replaced by single spaces and the string is
split at '"%S"'.  I.e., it's exactly what's drawn left-flushed for the
entry in the popup.  'accel' is then what's left after clean-up and came
after '"%S"', i.e., it's what appears as the right-flushed text of the
entry.  Please note that one or more of these pointers could under some
circumstances be 'NULL'.

Finally, the two member 'entry' and 'popup' are pointers to the entry
itself and the popup the callback function is invoked for - to find out
the popup the selected entry itself belongs to use the 'popup' member of
the entrys '*note FL_POPUP_ENTRY::' structure.

Please note: while in a callback you are only allowed to change the
values of the 'val' and 'user_data' members.  This can be useful in the
case of a cascade of selection callback calls since all the selection
callbacks receive the same structure (and this is also the structure
that finally gets passed back to the caller of '*note fl_popup_do()::')
at the end in order to implement more complex information interchange
between the callbacks involved.

The elements of a 'FL_POPUP_ENTRY' structure that might be of interest)
are
     typedef {
         FL_POPUP_ENTRY *prev;    /* previous popup entry */
         FL_POPUP_ENTRY *next;    /* next popup entry */
         int             type;    /* normal, toggle, radio, sub-popup, line*/
         unsigned int    state;   /* disabled, hidden, checked */
         int             group;   /* group (for radio entries only) */
         FL_POPUP       *sub;     /* sub-popup bound to entry */
         ...
     } FL_POPUP_ENTRY;
Note that you should not change the members of a '*note
FL_POPUP_ENTRY::' structure directly!  Use the appropriate functions
documented below to modify them instead.

'prev' and 'next' are pointers to the previous and the following popup
entry (or 'NULL' if none exists).

'type' tells what kind of popup entry this is.  There are five different
types:
'FL_POPUP_NORMAL'
     Normal popup entry with no special properties
'FL_POPUP_TOGGLE'
     "Toggle" or "binary" entry, drawn with a check-mark to its left if
     in "on" state
'FL_POPUP_RADIO'
     Radio entry, drawn with a circle to its left (color-filled when
     "on".  The 'group' member of the '*note FL_POPUP_ENTRY::' structure
     determines to which group the entry belongs.
'FL_POPUP_SUB'
     Entry for a sub-popup.  The 'sub' member of its *note
     FL_POPUP_ENTRY:: structure is a pointer to the sub-popup that gets
     shown when the mouse enters the entry.
'FL_POPUP_LINE'
     Not a "real" entry, just indicates that a separator line is to be
     drawn between the previous and the next entry.

Finally, the 'state' member can have the following values:
'FL_POPUP_NONE'
     No special state is set for the entry, the default.
'FL_POPUP_DISABLED'
     The entry is disabled, i.e., isn't selectable (and normally is
     drawn in a way to indicate this).
'FL_POPUP_HIDDEN'
     The entry is not drawn at all (and thus can't be selected).
'FL_POPUP_CHECKED'
     Only relevant for toggle and radio entries.  Indicates that the
     state of a toggle entry is "on" (drawn with a check-marker) and for
     a radio entry that it is the one in "on" state of its group.
The state can be a combination of the above constants by using a bitwise
OR.

The more interesting members of a 'FL_POPUP' structure are
     typedef struct {
         FL_POPUP       *next;        /* previously created popup */
         FL_POPUP       *prev;        /* later created popup */
         FL_POPUP       *parent;      /* for sub-popups: direct parent */
         FL_POPUP       *top_parent;  /* and top-most parent */
         Window          win;         /* window of the popup */
         FL_POPUP_ENTRY *entries;     /* pointer to list of entries */
         char           *title;       /* title string of the popup */
         ...
     } FL_POPUP;
Note again that you are not supposed to change the members of the
structure.

Like popup entries also popups are stored in a (doubly) linked list.
Thus the 'prev' and 'next' members of the structure are pointers to
popups created earlier or later.  If a popup is a sub-popup of another
popup then 'parent' points to the next higher level popup (otherwise
it's 'NULL').  In case there's a cascade of popups the 'top_parent'
member points to the "root" popup (i.e., the top-level popup), while for
popups that aren't sub-popups it always points back to the popup itself
(in that case 'parent' is 'NULL').

'win' is the window created for the popup.  It's 'None' (0) while the
popup isn't shown, so it can be used to check if the popup is currently
visible.

The 'entries' member points to the first element of the list of entries
of the popup.  See the '*note FL_POPUP_ENTRY::' structure documented
above on how to iterate over all entries.

Finally, 'title' is the title shown at the top of the popup (if one is
set).  Never try to change it directly, there ars the functions '*note
fl_popup_set_title()::' and '*note fl_popup_set_title_f()::', described
below, to do just that.

To remove a popup entry use
     int fl_popup_entry_delete(FL_POPUP_ENTRY *entry);
The function return 0 on success and -1 if it failed for some reasons.
Note that the function for a sub-popup entry also deletes the popup that
was associated with the entry!

You may also insert one or more entries into a popup at arbitrary places
using
     FL_POPUP_ENTRY *fl_popup_insert_entries(FL_POPUP *popup,
                                             FL_POPUP_ENTRY *after,
                                             const char *entries, ...);
'popup' is the popup the entries are to be inserted in, 'after' is the
entry after which the new entries are to be added (use 'NULL' if the new
entries are to be inserted at the very first position), and 'entries' is
the same kind if string as already used in '*note
fl_popup_add_entries()::', including all the available special
sequences.  The arguments indicated by '...' have to be given according
to the 'entries' string.

Finally, when you don't need a popup anymore simply call
     int fl_popup_delete(FL_POPUP *popup);
The function returns 0 on success and -1 on failure.  It's not possible
to call the function while the popup is still visible on the screen.
Calling it from any callback function is problematic unless you know for
sure that the popup to be deleted (and sub-popups of it) won't be used
later and thus normally should be avoided.

Above was described how to first generate a popup and then populate it.
But there's also a (though less general) method to create and populate a
popup in a single function call.  For this use
     FL_POPUP *fl_popup_create(Window win, const char *title,
                               FL_POPUP_ITEM *items);
The 'win' and 'title' arguments are the same as used in '*note
fl_popup_add()::', i.e., they are parent window for the popup (or '*note
fl_root::' or 'None') and the (optional, can be 'NULL') title for the
popup.

'items' is a pointer to an array of structures of the following form:
     typedef struct {
         const char  *text;        /* text of entry */
         FL_POPUP_CB  callback;    /* (selection) callback */
         const char  *shortcut;    /* keyboard shortcut description */
         int          type;        /* type of entry */
         int          state;       /* disabled, hidden, checked */
     } FL_POPUP_ITEM;
The array must contain one structure for each entry of the popup and
must end in a structure where at least the 'text' member is set to
'NULL'.

The 'text' member describes the text of the entry.  If it contains the
string '"%S"' the text is split up at this position and the first part
is used as the label drawn left-flushed for the entry and the second
part for the right-flushed part (for showing accelerator keys etc.).
Two more characters have a special meaning if they appear at the very
start of the string (and which then do not become part of the label
shown):
''_''
     Draw a separator line above this entry.
''/''
     This entry is a sub-popup entry and the following elements of the
     'items' array (until the first element with 'text' set to 'NULL'
     define the entries of the sub-popup.
Both ''_'' and ''/'' can appear at the start of the string, it doesn't
matter which one comes first.

The 'callback' member is a function to be invoked when the entry is
selected (irrelevant for sub-popup entries).  'shortcut' is a string,
encoding which keyboard shortcut keys can be used to select the item
(*note Shortcuts:: for details on how such a string has to be
assembled).

'type' describes the type of the entry and must be one of '*note
FL_POPUP_NORMAL::', '*note FL_POPUP_RADIO::' (all radio entries
automatically belong to the same group (numbered 'INT_MIN').  You can't
use '*note FL_POPUP_LINE::' or '*note FL_POPUP_SUB::'.  If you want a
sub-popup entry use '*note FL_POPUP_NORMAL::' and set ''/'' as the first
character of the 'text' member of the structure.  If you need a
separator line put a ''_'' at the start of the 'text' member string of
the entry which comes after the separator line.

Finally, the 'state' member can be 0 or the bitwise or of '*note
FL_POPUP_DISABLED::', '*note FL_POPUP_HIDDEN::' and '*note
FL_POPUP_CHECKED::'.  The first one makes the entry appear disabled and
non-selectable, the second will keep the entry from being drawn at all,
and the third one puts the entry into "on" state (relevant for toggle
and radio entries only).  If you try to set '*note FL_POPUP_CHECKED::'
for more than a single radio entry the last one you set if for "wins",
i.e., only this one will be in "on" state.  See below for a more
detailed discussion of these entry properties.

'*note fl_popup_create()::' does not allow to associate values or
pointers to user data to individual entries, set titles for sub-popups,
have radio entries belong to different groups or set enter or leave
callback functions (though there exist a number of functions to remedy
the situation in case such things are needed).

The function returns a pointer to the newly created popup (or 'NULL' on
failure).  You are guaranteed that each entry has been assigned a unique
value, starting at 0 and which is identical to the index of
corresponding element in the 'items' array, i.e., the first element
results in an entry assigned 0, the second entry gets 1 etc.

All functions working on popups or entries can, of course, be used on
popups and their entries generated via '*note fl_popup_create()::'.
They can be employed to remedy some of the limitations imposed by the
simpler popup creation API.

Here's an example of how to create a popup using 'fl_popup_create()':
     FL_POPUP *popup;

     FL_POPUP_ITEMS items[] = {
       {"Item 1%S^1", NULL, "^1", FL_POPUP_NORMAL, FL_POPUP_NONE    },
       {"Item 2%S^2", NULL, "^2", FL_POPUP_RADIO,  FL_POPUP_CHECKED },
       {"Item 3%S^3", NULL, "^3", FL_POPUP_RADIO,  FL_POPUP_NONE    },
       {"_/Item 4",   NULL, NULL, FL_POPUP_NORMAL, FL_POPUP_NONE    },
         {"Sub-item A",  cbA, "^A", FL_POPUP_NORMAL, FL_POPUP_DISABLED},
         {"Sub-item B",  cbB, "^B", FL_POPUP_TOGGLE, FL_POPUP_NONE    },
         {NULL,         NULL, NULL, 0,               0                },
       {"Item 5",     NULL, NULL, FL_POPUP_NORMAL, FL_POPUP_NONE    },
       {NULL,         NULL, NULL, 0,               FL_POPUP_NONE    }
     };

     popup = fl_popup_create(None, "Test", items);
This creates a new popup with the title '"Test"' and 5 entries as well
as a a sub-popup with two entries, that gets opened when the mouse is
over the entry labeled '"Item 4"'.

The first entry in the main popup has the label '"Item 1"' on the left
and '"^1"' of the right side.  It has no callback routine and can be
selected via the '<Crtl>1' shortcut.  It's just a normal menu entry.

The second entry has the label '"Item 2"' on the left and '"^2"' of the
right side, also no callack and '<Crtl>2' as its keyboard shortcut.
It's a radio entry that is in "on" state.  The third entry is like the
second, labels are '"Item 3"' and '"^3"' and it reacts to '<Crtl>3',
except that it's in "off" state.  The second and third label belong to
the same group (with the group number set to 'INT_MIN'), i.e., when the
third entry gets selected the second one gets switched to "off" state
(and vice versa).

Before the fourth entry a separator line will be drawn (that's the
effect of its text starting with ''_''.  It's a sub-popup entry (due to
the ''/'' at the start of its text).  It's label is simply '"Item 4"'
and no right hand label (but that isn't supposed to indicate that
sub-entries couldn't have shortcuts!).  It has no selection callback
(which wouldn't sense make sense for a sub-popup entry anyway).

The following three elements of the 'items' array are for the sub-popup
that gets opened when the mouse is over the fourth item of the main
popup.  In the sub-popup we first have an normal entry with label
'"Sub-item A"'.  The function 'cbA()' will be called when this entry of
the sub-popup is selected.  Then we have a second entry, labled
'"Sub-item B"', which is a currently disabled toggle entry in "off"
state.  If it weren't disabled its selection would result in the
callback function 'cbB()' getting called.  The next element of the
'items' array, having 'NULL' as its 'text' member, signifies the end of
the sub-popup.

Now that we're done with the sub-popup another entry in the main popup
follows, a normal entry with just a left-label of 'Item 5'.  The final
element of 'items', where 'text' is set to 'NULL' then signifies that
this is the end of the popup.

As there are functions to append to and insert entries into a popup with
a kind of format string, followed by a variable list of arguments, there
are also functions for adding and inserting entries using an array of
'*note FL_POPUP_ITEM::'.  These are
     FL_POPUP_ENTRY *fl_popup_add_items(FL_POPUP *popup,
                                        FL_POPUP_ITEM *items);
     FL_POPUP_ENTRY *fl_popup_insert_items(FL_POPUP *popup,
                                           FL_POPUP_ENTRY *after,
                                           FL_POPUP_ITEM  *items);
Both functions return the address of the first entry created on success
and 'NULL' on error.  The first argument is the popup the entries are to
be appended to or inserted into, the last argument the array of items
(as in the case of '*note fl_popup_create()::' at least the 'text'
member of the last element must be a 'NULL' pointer to indicate the
end).  'fl_popup_insert_items()' takes another argument, 'after', the
entry after which the new entries are to be inserted (if called with
'after' set to 'NULL' the new entries are inserted at the very start of
the popup).


File: xforms.info,  Node: Popup Interaction,  Next: Other Popup Routines,  Prev: Adding Popups,  Up: Part III Popups

22.2 Popup Interaction
======================

A popup will be drawn on the screen when the function
     FL_POPUP_RETURN *fl_popup_do(FL_POPUP *popup);
is called.  It only returns when the user either selects an entry or
closes it in some other way (e.g., by clicking outside the popup's
area).  When a selection was made the function returns a pointer to a
'*note FL_POPUP_RETURN::' structure with information about the entry
that was selected (please note that the structure is internal storage
belonging to the Forms Library and is re-used when the popup is shown
again, so copy out all data you may need to keep).  If no selection was
made (or one of the invoked callback routines returned a value of
'FL_IGNORE' (-1) 'NULL' is returned.

While the popup is shown the user can interact with the popup using the
mouse or the keyboard.  When the mouse is hovering over a selectable
entry of the popup the entry is highlighted, when the mouse reaches an
entry for a sub-popup, the associated sub-popup automatically gets
opened.  A selection is made by clicking on an entry (or, in case that
the popup was opened while a mouse button was pressed down, when the
mouse button is released).  Clicking outside the popups window (or,
depending on the "policy", see below, releasing the mouse button
somewhere else than over a selectable item) closes the popup without a
selection being made.

Popups also can be controlled via the keyboard.  First of all, on
pressing a key, the shortcuts set for items are evaluated and, if a
match is found, the corresponding entry is returned as selected (if the
popup currently shown is a sub-popup, first the shortcuts for this
sub-popup are checked, then those of its parent etc. until the top-most
popup has been reached and checked for).  The user can also navigate
through the selectable entires using the '<Up>' and '<Down>' arrow keys
and open and close sub-popups with the '<Right>' and '<Left>' cursor
keys.  Pressing the '<Home>' key highlights the first (selectable) entry
in the popup, '<End>' the last one.  By using the '<Esc>' key (or
'<Cancel>' if available) the currently shown popup is closed (if an
entry in a sub-popup was highlighted just this sub-popup is closed).
Finally, pressing '<Return>' while on a selectable entry results in this
entry being reported as selected.

Once the user has selected an entry its callback function is invoked
with a '*note FL_POPUP_RETURN::' structure as the argument.  When this
function returns, the callback for the popup the entry belongs to is
called with exactly the same structure.  If the popup is a sub-popup,
next the callback for its "parent" popup is invoked, again with the same
structure (except that the 'popup' member is changed each time to
indicate which popup the call is made for).  Repeat until the callback
for the top-most popup has been called.  Finally the structure used in
all those callback invocations is returned from '*note fl_popup_do()::'.
This chain of callback calls is interrupted when one of the callbacks
returns a value of 'FL_IGNORE' (-1).  In that case no further callbacks
are invoked and '*note fl_popup_do()::' returns 'NULL', i.e., from the
callers perspective it looks as if no selection has been made.  This can
be useful when one of the callbacks was already was able to do all the
work required on a selection.

Per default a popup stays open when the user releases the mouse button
anywhere else than on a selectable entry.  It only gets closed when the
user either selects an entry or clicks somewhere outside of the popup
area.  An alternative is a "drag-down" popup that gets closed whenever
the mouse button is released, even if the mouse isn't on the area of the
popup or a selectable entry.  To achieve this effect you can change the
"policy" using the function
     int fl_popup_set_policy(FL_POPUP *popup, int policy);
There are two values 'policy' can have:
'FL_POPUP_NORMAL_SELECT'
     Default, popup stays open until mouse button is released on a
     selectable entry or button is clicked outside the popups area.
'FL_POPUP_DRAG_SELECT'
     Popup is closed when the mouse button is released anywhere.
The function can be called with either a (valid) popup address, in which
case the policy for that popup is changed, or with a 'NULL' pointer to
change the default setting of the policy, used in the creation of new
popups.  The function returns the previous policy value or -1 on errors.

It's also possible to determine the policy setting by using
     int fl_popup_get_policy(Fl_POPUP *popup);
If called with the address of a (valid) popup the policy for this popup
(or its parent if one exists) gets returned.  If called with a 'NULL'
pointer the default policy used in creating new popups is returned.  On
error -1gets returned.

Calling the function with 'NULL' as the 'popup' argument changes the
default setting for the popups created afterwards.

If the popup is partially off-screen the user can push the mouse at the
screen borders in the direction of the currently invisible popup
entries.  This results in the popups window getting moved so that
previosuly invisible entries become accessible.  The popup window gets
shifted vertically in single entry steps, in horizontal direction by a
tenth of the screen width.  The delay between shifts is about 100 ms.


File: xforms.info,  Node: Other Popup Routines,  Next: Popup Attributes,  Prev: Popup Interaction,  Up: Part III Popups

22.3 Other Popup Routines
=========================

When '*note fl_popup_do()::' is called the popup per default is shown
with its left upper corner at the mouse position (unless the popup
wouldn't fit onto the screen).  Using
     void fl_popup_set_position(FL_POPUP *popup, int x, int y);
the position where the popup is drawn can be changed (but if it wouldn't
fit onto the screen at that position it will also changed
automatically).  'x' and 'y'.  to be given relative to the root window,
define the position of the upper left hand corner.  Using this function
for sub-popups is useless, they always get opened as near as possible to
the corresponding sub-popup entry.

When setting the position of a popup it can be useful to know the exact
sizes of its window in advance.  These can be obtained by calling
     int fl_popup_get_size(FL_POPUP *popup, unsigned int *w, unsigned int
     *h);
The function returns 0 on success and -1 on error (in case the supplied
'popup' argument isn't valid).  Please note that the reported values are
only valid until the popup is changed, e.g., by adding, deleting or
changing entries or changing the appearance of the popup.

A callback function 'cb()' of type '*note FL_POPUP_CB::', to be called
when a entry (or an entry of a sub-popup) is selected, can be associated
with a popup (or changed) using
     typedef int (*FL_POPUP_CB)(FL_POPUP_RETURN *);
     FL_POPUP_CB fl_popup_set_callback(FL_POPUP *popup, FL_POPUP_CB cb);
The function returns the old setting of the callback routine (on error
'NULL' is returned, which may indistinguishable from the case that no
callback was set before).

For an entry all three associated callback functions can be set via
     FL_POPUP_CB fl_popup_entry_set_callback(FL_POPUP_ENTRY *entry,
                                             FL_POPUP_CB cb);
     FL_POPUP_CB fl_popup_entry_set_enter_callback(FL_POPUP_ENTRY *entry,
                                                   FL_POPUP_CB enter_cb)
     FL_POPUP_CB fl_popup_entry_set_leave_callback(FL_POPUP_ENTRY *entry,
                                                   FL_POPUP_CB leave_cb);
The first function sets the callback invoked when the entry is selected,
the second when the mouse enters the area of the entry and the third,
when the mouse leaves that area.  All function return the previously set
callback or 'NULL' when none was set or an error occured.  'NULL' also
gets returned on errors.

There are three properties that can be set for a popup entry
'FL_POPUP_DISABLED'
     The entry is is shown as disabled and can't be selected.
'FL_POPUP_HIDDEN'
     The entry is not shown when the popup is opened.
'FL_POPUP_CHECKED'
     Relevant only for toggle and redio entries.  When set beside the
     label of a toggle entry a check-marker is drawn while the circle
     beside a radio button is drawn colored.
The "state" of an entry is the binary OR of these values which can be
set and queried using the functions
     unsigned int fl_popup_entry_set_state(FL_POPUP_ENTRY *entry,
                                           unsigned int state);
     unsigned int fl_popup_entry_get_state(FL_POPUP_ENTRY *entry);
'*note fl_popup_entry_set_state()::' returns the previous state on
success and 'UINT_MAX' (a value with all bits set) on failure.

Note that when setting '*note FL_POPUP_CHECKED::' for a radio entry all
other radio entries belonging to the same group automatically lose their
"on" (checked) property.

There are also three convenience function for clearing, raising and
toggling bits in the state of an entry.  Normally to clear a certain bit
of the state you have to first call '*note
fl_popup_entry_get_state()::', then clear the bit in the return value
and finally call '*note fl_popup_entry_set_state()::' with the result to
set the new state.  Use of these convenience functions allows to change
state bits in a single call.
     unsigned int fl_popup_entry_clear_state(FL_POPUP_ENTRY *entry,
                                             unsigned int what);
     unsigned int fl_popup_entry_raise_state(FL_POPUP_ENTRY *entry,
                                             unsigned int what);
     unsigned int fl_popup_entry_toggle_state(FL_POPUP_ENTRY *entry,
                                              unsigned int what);
The 'what' argument can be any value resulting from a bitwise OR of
'*note FL_POPUP_DISABLED::', '*note FL_POPUP_HIDDEN::' and '*note
FL_POPUP_CHECKED::' (thus you can clear, set or toggle one or more bits
of the state in a single call).  The functions all return the original
value of the state.

You may search for an entry in a popup by different criteria (please
note that the search also includes sub-popups of the popup, you can
identify them by checking the 'popup' member of the *note
FL_POPUP_ENTRY:: structure).  The search obviously will only deliver
reasonable results if what you're searching for is unique between all
the entries.

First, you can ask for the entry that had been created with a certain
text, including all the special sequences, by calling
     FL_POPUP_ENTRY *fl_popup_entry_get_by_text(FL_POPUP *popup,
                                                const char *text);
     FL_POPUP_ENTRY *fl_popup_entry_get_by_text_f(FL_POPUP *popup,
                                                  const char *fmt, ...);
The functions returns either a pointer to the entry found or 'NULL' on
failure (because either no entry with this text was found or the popup
doesn't exist).  (The functions differ in that the first one accepts
just a simple string while the second assembles the text from a format
string, just as it's used for 'printf()' etc., and an appropriate number
of following arguments.)

You may as well search by the left-flushed label parts of the entries as
shown on the screen (note that tab characters ''\t'' originally embedded
in the text used when creating the label have been replaced by single
spaces and backspace characters ''\b'' were removed as well as all
special sequences)
     FL_POPUP_ENTRY *fl_popup_entry_get_by_label(FL_POPUP *popup,
                                                 const char *label);
     FL_POPUP_ENTRY *fl_popup_entry_get_by_label_f(FL_POPUP *popup,
                                                   const char *fmt, ...);
Thus, since an entry created via a string like '"I\bt%Tem\t1%SCtrl+X"'
will shown with a left-flushed label part of '"Item 1"', this will be
found when searching with either this string or a format string fo e.g.,
'"Item %d"' and a following integer argument of '1'.

Another way to search for an entry is by its value as either specified
via the '"%x"' special sequence or assigned automatically by
     FL_POPUP_ENTRY *fl_popup_entry_get_by_value(FL_POPUP *popup,
                                                 long value);

Also the 'user_data' pointer associated with the entry can be used as
the search criterion:
     FL_POPUP_ENTRY *fl_popup_entry_get_by_user_data(FL_POPUP *popup,
                                                     void *user_data);

Finally one can try to find an entry by its current position in the
popup (note that here sub-popups aren't taken into consideration since
that would make the meaning of "position" rather hard to define) by
     FL_POPUP_ENTRY *fl_popup_entry_get_by_position(FL_POPUP *popup,
                                                    long position);
where 'posistion' is starting with 0, so when called with 0 the first
entry will be returned, when called with 1 you get the second entry etc.
Note that separator lines aren't counted but entries currently being
hidden are.


File: xforms.info,  Node: Popup Attributes,  Prev: Other Popup Routines,  Up: Part III Popups

22.4 Popup Attributes
=====================

Using
     void fl_popup_set_title(FL_POPUP *popup, const char *title);
     void fl_popup_set_title_f(FL_POPUP *popup, const char *fmt, ...);
     const char *fl_popup_set_title(FL_POPUP *popup);
the title of a popup can be changed or the currently set title
determined.  (The two functions for setting the title are just different
in the way the title is passed: the first one receives a simple string
while the second one assembles the title from a format string just like
the one used with 'printf()' etc.  and an appropriate number of
following arguments.)

To query or set the font the popups title is drawn in use
     void fl_popup_get_title_font(FL_POPUP *popup, int *size, int *style);
     void fl_popup_set_title_font(FL_POPUP *popup, int size, int style);
*Note Label Attributes and Fonts::, for details about the sizes and
styles that should be used.  The default size and style are '*note
FL_NORMAL_SIZE::' and '*note FL_EMBOSSED_STYLE::'.  This setting also
applies to sub-popups of the popup, thus setting a title font for
sub-popups is useless.

When called with the 'popup' argument set to 'NULL' the default settings
for popups generated later are returned or set.

Also the font for the entries of a popup can be queried or and set via
     void fl_popup_entry_get_font(FL_POPUP *popup, int *style, int *size);
     void fl_popup_entry_set_font(FL_POPUP *popup, int style, int size);
The defalt size is '*note FL_NORMAL_SIZE::' and the default style is
'*note FL_NORMAL_STYLE::'.  Again, the returned or set values also apply
to all sub-popups, so calling the function for sub-popups doesn't make
sense.

When called with 'popup' set to 'NULL' the default settings for popups
are returned or changed.

The width of a popup is calculated using the widths of the title and the
entries.  You can influence this width by setting a minimum width a
popup should have.  There are two functions for the minimum width:
     int fl_popup_get_min_width(FL_POPUP *popup);
     int fl_popup_set_min_width(FL_POPUP *popup, int min_width);
The first one returns the currently set minimum width (a negative return
value indicates an error).  The second allows sets a new minimum width.
Setting the minimum width to 0 or a negative value switches the use of
the minimum width off.  It returns the previous value (or a negative
value on error).

You can query or set the border width popups are drawn width (per
default it's set to '1').  To this purpose call
     int fl_popup_get_bw(FL_POPUP *popup);
     int fl_popup_set_bw(FL_POPUP *popup, int bw);
Please note that the border width setting is automatically applied also
to sub-popups, so there's no good reason to call these functions for
sub-popups.  The default border width is the same as that for objects.

The functions can also be called with 'popup' set to 'NULL' in which
case the default setting for the border width is returned or set,
respectively.

To change the cursor that is displayed when a popup is shown use
     void fl_popup_set_cursor(FL_POPUP *popup, int cursor_name);
Use one of the symbolic cursor names (shapes) defined by standard X or
the integer value returned by '*note fl_create_bitmap_cursor()::' or one
of the Forms Library's pre-defined symbolic names for the 'cursor_name'
argument.

Per default the cursor named '"XC_sb_right_arrow"' is used.  If the
function is called with 'popup' set to 'NULL' the default cursor for
popups generated afterwards is changed.

There are several colors used in drawing a popup.  These can be set or
queried with the functions
     FL_COLOR fl_popup_set_color(FL_POPUP *popup, int type,
                                 FL_COLOR color);
     FL_COLOR fl_popup_get_color(FL_POPUP *popup, int type);
where 'type' can be one of the following values:
'FL_POPUP_BACKGROUND_COLOR'
     Background color of the popup, default is 'FL_MCOL'.
'FL_POPUP_HIGHLIGHT_COLOR'
     Backgroud color an entry is drawn with when it's selectable and the
     mouse is on top of it, default is 'FL_BOTTOM_BCOL'.
'FL_POPUP_TITLE_COLOR'
     Color used for the title text of a popup, default is 'FL_BLACK'.
'FL_POPUP_TEXT_COLOR'
     Color normal used for entry texts, default is 'FL_BLACK'.
'FL_POPUP_HIGHLIGHT_TEXT_COLOR'
     Color of the entry text when it's selectable and the mouse is on
     top of it, default is 'FL_WHITE'.
'FL_POPUP_DISABLED_TEXT_COLOR'
     Color for drawing the text of disabled entries, default is
     'FL_INACTIVE_COL'.
'FL_POPUP_RADIO_COLOR'
     Color the circle drawn for radio entris in "on" state is drawn in.

When setting a new color the color previously used is returned by '*note
fl_popup_set_color()::'.  Calling these functions for sub-popups doesn't
make sense since sub-popups are always drawn in the colors set for the
parent popup.

When called with 'popup' set to 'NULL' the functions return or set the
default colors of popups created afterwards.

To change the text of a popup entry call
     int fl_popup_entry_set_text(FL_POPUP_ENTRY *entry, const char *text);
Please note that in the text no special sequences except '"%S"' (at
which place the text is split to make up the left- and right-flushed
part of the label drawn) are recognized.

The shortcut keys for a popup label can be changed using
     void fl_popup_entry_set_shortcut(FL_POPUP_ENTRY *entry,
                                      const char *shortcuts);
*Note Shortcuts::, for details on how such a string has to look like.

The value assigned to a popup entry can be changed via
     long fl_popup_entry_set_value(FL_POPUP_ENTRY *entry, long value);
The function returns the previous value.

Also the user data pointer associated with a popup entry can be modified
by calling
     void *fl_popup_entry_set_user_data(FL_POPUP_ENTRY *entry,
                                        void *user_data);
The function returns the previous setting of 'user_data'.

To determine to which group a radio entry belongs call
     int fl_popup_entry_get_group(FL_POPUP_ENTRY *entry);
Obviously, this function only makes much sense when applied to radio
entries.  It returns the group number on success and 'INT_MAX' on
failure (that's why 'INT_MAX' shouldn't be used for group numbers).

To assign a radio entry to a different group call
     int fl_popup_entry_set_group(FL_POPUP_ENTRY *entry, int group);
Again, for obvious reasons, the function should normally only be called
for radio entries.  It returns the previous group number on success and
'INT_MAX' on failure.  If one of the entries of the new group was in
"on" state the entries state will be reset to "off" if necessary.

For entries other than radio entries the group isn't used at all.  So,
theoretically, it could be used to store a bit of additional
information.  If that would be good programming practice is another
question...

Finally, the sub-popup associated with a sub-popup-entry can be queried
or changed using the functions
     FL_POPUP *fl_popup_entry_get_subpopup(FL_POPUP_ENTRY *entry);
     FL_POPUP *fl_popup_entry_get_subpopup(FL_POPUP_ENTRY *entry,
                                           FL_POPUP *subpopup);
Obviously, calling these functions only makes sense for sub-popup
entries.

'*note fl_popup_entry_get_subpopup()::' returns the address of the
sub-popup associated with the entry or 'NULL' on failure.

To change the sub-popup of an entry a valid sub-popup must be passed to
'*note fl_popup_entry_set_subpopup()::', i.e., the sub-popup must not
already be a sub-popup of another entry or the popup the entry belongs
to itself.  You also can't set a new sub-popup while the old sub-popup
associated with the entry or the popup to become the new sub-popup is
shown.  On success the address of the new sub-popup is returned, on
failure 'NULL'.

Note that this function deletes the old sub-popup that was associated
with the popup.


File: xforms.info,  Node: Part III Deprecated Objects,  Next: Part IV,  Prev: Part III Popups,  Up: Top

23 Deprecated Objects
*********************

In this chapter describes object types that have been replaced by newer
ones.  But they will remain part of XForms and also can be used in new
programs.  But there probably will be not more support for these objects
than bug fixes etc.

* Menu:

* Choice Object:  Choice Object
* Menu Object:    Menu Object
* XPopup:         XPopup


File: xforms.info,  Node: Choice Object,  Next: Menu Object,  Up: Part III Deprecated Objects

23.1 Choice Object
==================

A choice object is an object that allows the user the choose among a
number of choices.  The current choice is shown in the box of the choice
object.  The user can either cycle through the list of choices using the
middle or right mouse button or get the list as a menu using the left
mouse button.

* Menu:

* Adding Choice Objects:   Adding Choice Objects
* Choice Types:            Choice Types
* Choice Interaction:      Choice Interaction
* Other Choice Routines:   Other Choice Routines
* Choice Attributes:       Choice Attributes
* Remarks:                 Choice Remarks


File: xforms.info,  Node: Adding Choice Objects,  Next: Choice Types,  Up: Choice Object

23.1.1 Adding Choice Objects
----------------------------

To add a choice object to a form use the routine
     FL_OBJECT *fl_add_choice(int type, FL_Coord x, FL_Coord y,
                              FL_Coord w, FL_Coord h, const char *label);
It shows a box on the screen with the label to the left of it and the
current choice (empty in the beginning), centered in the box.


File: xforms.info,  Node: Choice Types,  Next: Choice Interaction,  Prev: Adding Choice Objects,  Up: Choice Object

23.1.2 Choice Types
-------------------

The following types are available:
'FL_NORMAL_CHOICE'
     Middle/right mouse button shortcut.

'FL_NORMAL_CHOICE2'
     Same as 'FL_NORMAL_CHOICE' except drawn differently.

'FL_DROPLIST_CHOICE'
     Menu is activated only by pressing and releasing the mouse on the
     arrow.


File: xforms.info,  Node: Choice Interaction,  Next: Other Choice Routines,  Prev: Choice Types,  Up: Choice Object

23.1.3 Choice Interaction
-------------------------

Beside simply opening up the popup behind the choice object and
selecting an entry with the left mouse button you can also use the
middle and right mouse buttons and the scroll wheel: a short click with
the middle mouse button selects the entry before the currently selected
one, a click with the right mouse button the next.  Keeping the middle
or right mouse button pressed down slowly cycles trough the entries,
backward or forward.  The same can be down with the sroll wheel.

In both cases, whenever a choice entry is selected (even when it is the
original one) the object is returned to the application program.  But
you can control the condition under which the choice object gets
returned to the application by using the function
     int fl_set_object_return(FL_OBJECT *obj, unsigned int when)
where 'when' can have the following values
'*note FL_RETURN_NONE::'
     Never return or invoke callback.

'*note FL_RETURN_END_CHANGED::'
     Return or invoke callback if end of interaction and selection of an
     item coincide.

'*note FL_RETURN_CHANGED::'
     Return or invoke callback whenever an item is selected (this is the
     default).

'*note FL_RETURN_END::'
     Return or invoke callback on end of an interaction.

'*note FL_RETURN_ALWAYS::'
     Return (or invoke callback) whenever the interaction ends and/or an
     item is selected.


File: xforms.info,  Node: Other Choice Routines,  Next: Choice Attributes,  Prev: Choice Interaction,  Up: Choice Object

23.1.4 Other Choice Routines
----------------------------

There are a number of routines to change the list of possible choices.
To add a line to a choice object use
     int fl_addto_choice(FL_OBJECT *obj, const char *text);
     int fl_addto_choice_f(FL_OBJECT *obj, const char *fmt, ...);
The function returns the number of the new item.  The items in the list
are numbered in the order in which they were inserted.  The first item
has number 1, etc.  The two functions differ in that the first one
accepts just a simple string while for the second the text is assembled
from a format string as used by 'printf()' etc.  and the following
arguments.

Note that, because a choice object uses a popup, the string passed with
'*note fl_addto_choice()::' cann also contain some additional
information not directly shown in the entries text.  E.g., you can
create several entries as once if the string you pass to '*note
fl_addto_choice()::' contains ''|'' characters - these aren't shown but
instead are treated as separators between the strings for the entries.
Some extra control sequences, starting with the character ''%'' can also
be embedded (*note Creating XPopups::), thus a literal ''%'' in a string
must be escaped by doubling it.

To delete a line use:
     void fl_delete_choice(FL_OBJECT *obj, int line);

Whenever the application program wants to clear the complete list of
choices it should use the routine
     void fl_clear_choice(FL_OBJECT *obj)

One can also replace a line using
     void fl_replace_choice(FL_OBJECT *obj, int line, const char *text);
     void fl_replace_choice(FL_OBJECT *obj, int line, const char *fmt, ...);
(The second function assembles the new text from a format string as used
for 'printf()' etc.  and the following arguments.)

To obtain the currently selected item in the choice object use the call
     int fl_get_choice(FL_OBJECT *obj);
The function returns the number of the current choice (0 if there is no
choice).

You can also obtain the text of the currently selected choice item using
the call
     const char *fl_get_choice_text(FL_OBJECT *obj);
'NULL' is returned when there is no current choice.

To obtain the text of an arbitrary choice item, use the following
routine
     const char *fl_get_choice_item_text(FL_OBJECT *obj, int n);

To obtain the total number of choice items, use the following function
     int fl_get_choice_maxitems(FL_OBJECT *obj);

One can set various attributes of an item using the following routine
     void fl_set_choice_item_mode(FL_OBJECT *obj, int numb, int mode);
Here 'mode' is the same as that used for menu objects (see above).  See
also *note XPopup::, for details.

To find about those settings use
     int fl_get_choice_item_mode(FL_OBJECT *obj, int numb);

You can use the follow routine to populate a choice object at once,
including mode and shortcut, by using
     int fl_set_choice_entries(FL_OBJECT *obj, FL_PUP_ENTRY *entries);
where 'entries' is a pointer to a 'FL_PUP_ENTRY' structure (terminated
by a 'NULL' text field) as already described above for the function
'*note fl_set_menu_entries()::'.  Also see *note XPopup::, for more
details.  Please note that for choice objects no nested entries are
permitted and the item callback functions are ignored.  The function
returns the number of items added to the choice object.

Finally, the application program can set the currently selected entry of
the choice using a call of
     void fl_set_choice(FL_OBJECT *obj, int line);
     void fl_set_choice_text(FL_OBJECT *obj, const char *txt)
     void fl_set_choice_text_f(FL_OBJECT *obj, const char *fmt, ...)
where 'txt' (for 'fl_set_choice_text()' or the text resulting from the
expansion of the 'printf()'-compatible format string and the following
arguments for 'fl_set_choice_text_f()' must must be the text of exactly
one of the choice items.  For example, after the following choice is
created
     fl_addto_choice(obj,"item1|item2|item3");
You can select the second item by using any of the following lines
     fl_set_choice(obj, 2);
     fl_set_choice_text(obj, "item2");
     fl_set_choice_text_f(obj, "item%d", 2 );


File: xforms.info,  Node: Choice Attributes,  Next: Choice Remarks,  Prev: Other Choice Routines,  Up: Choice Object

23.1.5 Choice Attributes
------------------------

Don't use 'FL_NO_BOX' as the boxtype for a choice object.

The first color argument ('col1' to '*note fl_set_object_color()::'
controls the color of the box and the second ('col2') the color of the
text in the box.

The current choice by default is shown centered in the box.  To change
the alignment of the choice text in the box, use the following routine
     void fl_set_choice_align(FL_OBJECT *obj, int align);

To set the font size used inside the choice object use
     void fl_set_choice_fontsize(FL_OBJECT *obj, int size);

To set the font style used inside the choice object use
     void fl_set_choice_fontstyle(FL_OBJECT *obj, int style);

Note that the above functions only change the font inside the choice
object, not the font used in the popup.  To change the font used in the
popup, use the XPopup functions '*note fl_setpup_default_fontsize()::'
and '*note fl_setpup_default_fontstyle()::'.  Note that these functions
influence the font settings of all popups!  *Note Label Attributes and
Fonts::, for details on font sizes and styles.

Normally the pop-up shown for the choice objects will be displayed at
the current mouse position or, for those of type 'FL_DROPLIST_CHOICE',
directly below the choice object.  This can be modified by a call of the
function
     int fl_set_choice_align_bottom(GL_OBJECT *obj, int flag);
If 'flag' is '0' the normal behaviour is used, but when 'flag' is '1'
the popup will be displayed with its lower right hand corner at the
current mouse position or, for objects of type 'FL_DROPLIST_CHOICE'
above the choise object.  The function returns the previously set value
for 'flag'.


File: xforms.info,  Node: Choice Remarks,  Prev: Choice Attributes,  Up: Choice Object

23.1.6 Remarks
--------------

See 'choice.c' for an example of the use of choice objects.


File: xforms.info,  Node: Menu Object,  Next: XPopup,  Prev: Choice Object,  Up: Part III Deprecated Objects

23.2 Menu Object
================

Also menus can be added to forms.  These menus can be used to let the
user choose from many different possibilities.  Each menu object has a
box with a label in it in the form.  Whenever the user presses the mouse
inside the box (or moves the mouse on top of the box) a pop-up menu
appears.  The user can then make a selection from the menu.

* Menu:

* Adding Menu Objects:   Adding Menu Objects
* Menu Types:            Menu Types
* Menu Interaction:      Menu Interaction
* Other Menu Routines:   Other Menu Routines
* Menu Attributes:       Menu Attributes
* Remarks:               Menu Remarks


File: xforms.info,  Node: Adding Menu Objects,  Next: Menu Types,  Up: Menu Object

23.2.1 Adding Menu Objects
--------------------------

To add a menu to a form use the routine
     FL_OBJECT *fl_add_menu(int type, FL_Coord x, FL_Coord y,
                            FL_Coord w, FL_Coord h, const char *label);
It shows a box on the screen with the label centered in it.


File: xforms.info,  Node: Menu Types,  Next: Menu Interaction,  Prev: Adding Menu Objects,  Up: Menu Object

23.2.2 Menu Types
-----------------

The following types are available:
'FL_PUSH_MENU'
     The menu appears when the user presses a mouse button on it.

'FL_PULLDOWN_MENU'
     The menu appears when the user presses a mouse button on it.

'FL_TOUCH_MENU'
     The menu appears when the user move the mouse inside it.

'FL_PUSH_MENU' and 'FL_PULLDOWN_MENU' behave rather similar.  When you
click on a 'FL_PUSH_MENU' per default a pop-up window gets opened on top
of the 'FL_PUSH_MENU' menu's box that has a label at the top, indicating
the currently selected menu item.  The pop-up window stays open until
you either select an item or press a mouse button somewhere outside the
pop-up window.

When you click on 'FL_PULLDOWN_MENU' also a pop-up window is shown, but
directly below the menu's box.  This pop-up window has no label and it
only stays open until you release the mouse button.

'FL_PUSH_MENU' and 'FL_PULLDOWN_MENU' can be made even more similar by
using the '*note fl_set_menu_notitle()::' function (see below).  This
changes it's properties so that the pop-up window also appears below the
menu's box and that no label is shown in the pop-up window.  The only
remaining difference then is that a 'FL_PUSH_MENU' only gets closed when
a menu item is selected or the user presses the mouse outside of the
pop-up window while a 'FL_PULLDOWN_MENU' also gets closed when the mouse
button is released.


File: xforms.info,  Node: Menu Interaction,  Next: Other Menu Routines,  Prev: Menu Types,  Up: Menu Object

23.2.3 Menu Interaction
-----------------------

When the menu appears the user can make a selection using the left mouse
button or make no selection by clicking outside the menu (or by simply
releasing the mouse button in case of a 'FL_PULLDOWN_MENU' type menu.
Normally when he makes a selection the menu object is returned by the
interaction routines.

You can control the condition under which the menu object gets returned
to the application by using the function
     int fl_set_object_return(FL_OBJECT *obj, unsigned int when)
where 'when' can have the following values
'*note FL_RETURN_NONE::'
     Never return the object or invoke its callback.

'*note FL_RETURN_END_CHANGED::'
     Return or invoke callback if end of interaction and selection of an
     item coincide (this is the default for all menu objects except
     those of type 'FL_TOUCH_MENU').

'*note FL_RETURN_CHANGED::'
     Return or invoke callback whenever an item is selected (this is the
     default for all menu objects of type 'FL_TOUCH_MENU').

'*note FL_RETURN_END::'
     Return or invoke callback on end of an interaction.

'*note FL_RETURN_ALWAYS::'
     Return (or invoke callback) whenever the interaction ends and/or an
     item is selected.


File: xforms.info,  Node: Other Menu Routines,  Next: Menu Attributes,  Prev: Menu Interaction,  Up: Menu Object

23.2.4 Other Menu Routines
--------------------------

There are two ways to populate a menu, i.e., add items.  The first one
is a bit more complex but allows for more flexibility, e.g., later
adding and removing items, associating callbacks with individual items
etc.  For the more simple (and in many cases sufficient) method see the
function '*note fl_set_menu_entries()::'.

To set the actual menu for a menu object, use the routine
     void fl_set_menu(FL_OBJECT *obj, const char *menustr, ...);
'menustr' describes the menu in the form used by XPopups (*note
XPopup::).  In the simplest case it just contains the texts for the menu
items, separated by a bar (''|''), e.g., '"First|Second|Third"'.  But
it's also possible to employ special tags (*note Creating XPopups::)
that can be used to indicate special attributes (radio, toggle and
greyed-out, for example).  For this usage the unspecified arguments (the
'...' in the function call) can be used t add neceassary information.
Whenever the user selects a menu item, a pointer to the menu object it
belongs to is returned to the application program.

Please note that if you call '*note fl_set_menu()::' on a menu that
already contains items the existing items are replaced by the new ones -
the function calls '*note fl_clear_menu()::' internally before the new
items are added.

If you explicitely assign a menu item ID to a menu, using the special
tag '%x', it is your responsibility to make sure that this ID isn't
already used by a different menu item in the same menu.  Failure to do
so may make it impossible to use the menu properly.  All functions
working on items expect the menu item ID as one of their arguments.
Also note that only values that fit into a 'char' can be used, so the
range is restricted to the interval '[-128, 127]' on most machines with
a signed 'char' type and to '[0, 255]' on those with an unsigned 'char'
type.  For portability reasons it's thus to be recommended to restrict
the range to '[0, 127]'.

In case you don't set menu item IDs they are assigned automatically with
the first item obtaining the menu item ID 1, the next 2 etc., i.e., it
directly reflects the position of the item in the menu.

It is also possible to add menu items to an existing menu using a call
of
     int fl_addto_menu(FL_OBJECT *obj, const char *menustr, ...);
where 'menustr' is a string of the same form as used in '*note
fl_set_menu()::' (you can add one or more new menu items this way).

Also routines exist to delete a particular menu item or change it:
     void fl_delete_menu_item(FL_OBJECT *obj, int miid);
     void fl_replace_menu_item(FL_OBJECT *obj, int miid,
                                const char *menustr, ...);
'miid' is the menu item ID. 'menustr' must be a string as used in '*note
fl_set_menu()::' with the only difference that only a single menu item
can be specified.

Please note: when deleting a menu item all other items keep their menu
item IDs.  The menu item ID of the deleted menu item isn't re-used when
new items are added later.  Instead for each menu an internal counter
exists that gets incremented for each menu item added and which value is
used for the menu item ID unless one is explicitely assigned to the menu
item.  The counter oly gets reset to 1 when the menu is cleared used
'*note fl_clear_menu()::'.

The menu item ID of a menu item changed by using '*note
fl_replace_menu_item()::' does not change unless the library is
explicitely asked to via '%x' in 'menustr'.

For most applications, the following routine may be easier to use at the
expense of somewhat restrictive value a menu item can have as well as a
loss of the ability to delete menu items or associate callbacks with
menu items.
     int fl_set_menu_entries(FL_OBJECT *obj, FL_PUP_ENTRY *ent);
where 'ent' is a pointer to an array of structure of the following type,
terminated by an element, where at least the 'text' member is a 'NULL'
pointer:
     typedef struct {
         const char *text;
         FL_PUP_CB callback;
         const char *shortcut;
         int mode;
     } FL_PUP_ENTRY;
The meaning of each member is explained in Section 21.3.  For menus,
item callback function can be 'NULL' if the menu callback handles the
interaction results.  See demo program 'popup.c' for an example use of
'*note fl_set_menu_entries()::'.

The function '*note fl_set_menu_entries()::' works by creating and
associating a popup menu with the menu object.  The popup ID is returned
by the function.  Whenever the function is called, the old popup
associated with the object (if one exists) is freed and a new one is
created.  Although you can manipulate the menu either through the menu
API (but adding and removing menu items is not supported for menus
created this way ) or popup API, the application should not free the
popup directly and use '*note fl_clear_menu()::' instead.

To clear the whole menu use
     void fl_clear_menu(FL_OBJECT *obj);

To find the menu item selected by the user use
     int fl_get_menu(FL_OBJECT *obj);
The the function returns the menu item ID. In the simplest possible case
this is just the position of the menu item (starting at 1).  This stops
to be true when either IDs have been explicitely assigned to items or
items have been deleted.  In that case the following rules apply:
  1. A menu item ID may have been assigned to a menu item using '%xn' in
     the string for the text of the menu item.
  2. Menu items can get associated with a callback function that is
     executed when the menu item is selected.  The callback function is
     of type '*note FL_PUP_CB::' and receives the menu item ID of the
     selected menu.  If such a callback is set for a menu item the
     return value of '*note fl_get_menu()::' is the return value of this
     function instead of the menu item ID that would have been returned
     otherwise.

To obtain the text of any item, use the following routine
     const char *fl_get_menu_item_text(FL_OBJECT *obj, int miid);
where 'miid' is the menu item ID. If 'n' isn't a valid menu iem ID item
'NULL' is returned.

To obtain the text of the selected enu item use
     const char *fl_get_menu_text(FL_OBJECT *obj);

To obtain the total number of menu items, use the function
     int fl_get_menu_maxitems(FL_OBJECT *obj);

One can change the appearance of different menu items.  In particular,
it is sometimes desirable to make grey-out menu items and make them
unselectable or to put boxes with and without checkmarks in front of
them.  This can be done using the routine:
     void fl_set_menu_item_mode(FL_OBJECT *obj, int miid, unsigned mode);
'miid' is the menu index ID of the memu item you want to change.  'mode'
represents the special properties you want to apply to the chosen item.
You can specify more than one at a time by adding or bitwise OR-ing
these values together.  For this parameter, the following symbolic
constants exist:
'FL_PUP_NONE'
     No special display characteristic, the default.

'FL_PUP_BOX'
     "Binary" entry, i.e., an entry that stands for a choice that can be
     switched on and off.  Displayed with an unchecked box to the left.

'FL_PUP_RADIO'
     "Radio" item belonging to a group, so that gets automatically
     switched off when another item of the group is selected.  Displayed
     with a diamoned-shaped box at the left.

'FL_PUP_GREY'
     To be OR-ed with one of the above to make that item appear
     greyed-out and disable it (i.e., not selectable anymore).

'FL_PUP_CHECK'
     To be OR-ed with one of 'FL_PUP_BOX' and 'FL_PUP_RADIO' to make the
     box to the left appear checked or pushed.

There is also a routine that can be used to obtain the current mode of
an item after interaction, mostly useful for toggle or radio items:
     unsigned int fl_get_menu_item_mode(FL_OBJECT *obj, int miid);

While a callback associated with a menu entry can be set when it is
created it can also set later on or be changed.  For this use the
function
     FL_PUP_CB fl_set_menu_item_callback(FL_OBJECT *ob,
                                         int numb, FL_PUP_CB cb);
where 'numb' is the menu entries ID and 'cb' is the callback function of
type '*note FL_PUP_CB::' (or 'NULL' to disable a callback).  The return
value is a pointer to the previously used callback function (or 'NULL').

It is often useful to define keyboard shortcuts for particular menu
items.  For example, it would be nice to have '<Alt>s' behave like
selecting "Save" from a menu.  This can be done using the following
routine:
     void fl_set_menu_item_shortcut(FL_OBJECT *obj, int miid,
                                    const char *str);
'miid' is the menu item ID of the menu item under consideration.  'str'
contains the shortcut for the item.  (Actually, it can contain more
shortcuts for the same item.)  *Note Shortcuts::, for more information
about shortcuts.

Finally there is the routine:
     void fl_show_menu_symbol(FL_OBJECT *obj, int yes_no);
With this routine you can indicate whether to show a menu symbol at the
right of the menu label.  By default no symbol is shown.

